<!-- Copyright (c) 2025 Yusuke Yoshida — MIT License
-->
<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<title>Polar Pitch Map — Disk physics, MIDI In + MIDI File</title>
<style>
  html,body{
    margin:0;height:100%;background:#111;color:#ddd;font:14px system-ui;
    -webkit-user-select:none;user-select:none;-webkit-touch-callout:none;
  }
  :root{ --ui-scale:1; }
  #ui{position:fixed;top:75px;left:8px;gap:12px;display:flex;flex-wrap:wrap;align-items:center;z-index:2;
       transform-origin:top left; transform:scale(var(--ui-scale));
       max-height:calc(100vh - 110px); overflow-y:auto; -webkit-overflow-scrolling:touch; padding:4px 6px;}
  canvas{
    display:block;width:100vw;height:100vh;touch-action:none;
    -webkit-user-select:none;user-select:none;-webkit-touch-callout:none;
  }
  label{display:flex;gap:6px;align-items:center}
  input[type=range]{width:180px}
  button,select{padding:6px 10px}
  .sep{width:1px;height:22px;background:#444;margin:0 4px}

  /* UI show/hide トグル */
  #uiToggle{position:fixed;top:50px;right:8px;z-index:3;opacity:0.8}
  #uiToggle:hover{opacity:1}
  #diskLock{position:fixed;top:84px;right:8px;z-index:3;opacity:0.8}
  #diskLock:hover{opacity:1}
</style>

<button id="uiToggle" aria-pressed="false">UI隠す</button>
<button id="diskLock" aria-pressed="false">円盤ロック</button>

<div id="ui">
  <!-- language -->
  <label id="langWrap" data-lbl="language">
    <select id="lang">
      <option value="en">English</option>
      <option value="pt-BR">Português (Brasil)</option>
      <option value="es-MX">Español (México)</option>
      <option value="ja" selected>日本語</option>
      <option value="ko">한국어</option>
      <option value="zh">简体中文</option>
    </select>
  </label>

  <button id="resetSettings" type="button">初期設定に戻す</button>

  <label id="presetWrap" data-lbl="presetSlot">
    <select id="presetSlot"></select>
  </label>
  <button id="savePreset" type="button">プリセット保存</button>
  <button id="loadPreset" type="button">プリセット読込</button>

  <!-- anchor: 水面固定 or ディスク固定 -->
  <label id="anchorWrap" data-lbl="anchor">
    <select id="anchor">
      <option value="water">水面固定</option>
      <option value="disk">ディスク固定</option>
    </select>
  </label>

  <!-- MIDI inputs（常時） -->
  <label id="devWrap" data-lbl="device">
    <select id="midiDev"></select>
  </label>
  <label id="allWrap" data-lbl="allInputs">
    <input id="midiAll" type="checkbox" checked>
  </label>

  <!-- ライブ入力の音声再生ON/OFF -->
  <label id="liveMonWrap" data-lbl="liveSound">
    <input id="liveMon" type="checkbox" checked>
  </label>

  <!-- torque scope -->
  <label id="excludeWrap" data-lbl="torqueExclude">
    <select id="exclude">
      <option value="filled">塗りつぶし</option>
      <option value="unfilled" selected>非塗りつぶし</option>
    </select>
  </label>

  <!-- ω max（対数目盛：0.01〜100 rad/s） -->
  <label id="omaxWrap" data-lbl="omegaMax">
    <input id="omegaMax" type="range" min="-2" max="2" step="0.01" value="0.301" list="omTicks">
    <datalist id="omTicks">
      <option value="-2"><option value="-1"><option value="0"><option value="1"><option value="2">
    </datalist>
    <span id="omegaMaxVal">2.00 rad/s</span>
  </label>

  <!-- damping（比例：0〜99 %/s） -->
  <label id="dampWrap" data-lbl="damping">
    <input id="damp" type="range" min="0" max="99" step="0.001" value="99" list="dampTicks">
    <datalist id="dampTicks">
      <option value="0"><option value="25"><option value="50"><option value="75"><option value="99">
    </datalist>
    <span id="dampVal">99%/s</span>
  </label>

  <!-- snap ω when α=0 -->
  <label id="snapAlphaWrap" data-lbl="snapZeroAlpha">
    <input id="snapAlpha" type="checkbox" checked>
  </label>

  <!-- UI opacity -->
  <label id="uiopWrap" data-lbl="uiOpacity">
    <input id="uiop" type="range" min="10" max="100" step="1" value="85">
    <span id="uiopVal">85%</span>
  </label>

  <!-- disk physics -->
  <label id="massWrap" data-lbl="diskMass">
    <input id="mass" type="range" min="-2" max="2" step="0.001" value="-0.431">
    <span id="massVal">M=0.37</span>
  </label>

  <label id="lowCutWrap" data-lbl="lowCut">
    <input id="lowCut" type="range" min="0" max="6" step="1" value="0" list="lowCutTicks">
    <datalist id="lowCutTicks">
      <option value="0"><option value="1"><option value="2"><option value="3"><option value="4"><option value="5"><option value="6">
    </datalist>
    <span id="lowCutVal">0</span>
  </label>

  <label id="highCutWrap" data-lbl="highCut">
    <input id="highCut" type="range" min="0" max="6" step="1" value="0" list="highCutTicks">
    <datalist id="highCutTicks">
      <option value="0"><option value="1"><option value="2"><option value="3"><option value="4"><option value="5"><option value="6">
    </datalist>
    <span id="highCutVal">0</span>
  </label>

  <!-- visuals -->
  <label id="lineAWrap" data-lbl="lineAlpha">
    <input id="lineA" type="range" min="0" max="100" step="1" value="50">
    <span id="lineAVal">50%</span>
  </label>

  <label id="straightLineAWrap" data-lbl="straightLineAlpha">
    <input id="straightLineA" type="range" min="0" max="100" step="1" value="20">
    <span id="straightLineAVal">20%</span>
  </label>

  <label id="noteGuideAWrap" data-lbl="noteGuideAlpha">
    <input id="noteGuideA" type="range" min="0" max="100" step="1" value="15">
    <span id="noteGuideAVal">15%</span>
  </label>

  <label id="noteGuideLabelAWrap" data-lbl="noteGuideLabelAlpha">
    <input id="noteGuideLabelA" type="range" min="0" max="100" step="1" value="5">
    <span id="noteGuideLabelAVal">5%</span>
  </label>

  <label id="waterAWrap" data-lbl="waterAlpha">
    <input id="waterA" type="range" min="0" max="100" step="1" value="15">
    <span id="waterAVal">15%</span>
  </label>

  <label id="movNumAWrap" data-lbl="movNumAlpha">
    <input id="movNumA" type="range" min="0" max="100" step="1" value="28">
    <span id="movNumAVal">28%</span>
  </label>

  <label id="movNumSizeWrap" data-lbl="movNumSize">
    <input id="movNumSize" type="range" min="10" max="60" step="1" value="28">
    <span id="movNumSizeVal">28px</span>
  </label>

  <label id="labelSizeWrap" data-lbl="labelSize">
    <input id="labelSize" type="range" min="8" max="36" step="1" value="12">
    <span id="labelSizeVal">12px</span>
  </label>

  <label id="labelBGWrap" data-lbl="labelBG">
    <input id="labelBG" type="range" min="0" max="100" step="1" value="0">
    <span id="labelBGVal">0%</span>
  </label>

  <label id="labelAlphaWrap" data-lbl="labelAlpha">
    <input id="labelAlpha" type="range" min="0" max="100" step="1" value="0">
    <span id="labelAlphaVal">0%</span>
  </label>

  <!-- MIDI File controls（常時表示） -->
  <span class="sep"></span>
  <label id="fileWrap" data-lbl="midiFile">
    <input id="midiFile" type="file" accept=".mid,.midi,audio/midi,audio/x-midi">
  </label>
  <label id="transposeWrap" data-lbl="transpose">
    <input id="transpose" type="range" min="-6" max="6" step="1" value="0">
    <span id="transposeVal">+0 半音</span>
  </label>
  <label id="fileOpWrap" data-lbl="fileOp">
    <select id="fileOp">
      <option value="play">再生</option>
      <option value="train" selected>トレーナー</option>
    </select>
  </label>
  <label id="trainerModeWrap" data-lbl="trainerMode">
    <select id="trainerMode">
      <option value="gate" selected>和音ゲート</option>
      <option value="realtime">リアルタイム（リング）</option>
    </select>
  </label>
  <span id="playBtns">
    <button id="btnPlay">▶︎</button>
    <button id="btnPause">⏸</button>
    <button id="btnStop">⏹</button>
  </span>
  <label id="seekWrap" data-lbl="seek">
    <input id="seek" type="range" min="0" max="1000" step="0.01" value="0" disabled>
    <span id="seekTime">0:00 / 0:00</span>
  </label>
  <span id="trainBtns">
    <button id="btnStartTrain">開始/リスタート</button>
    <button id="btnPrev">◀︎</button>
    <button id="btnNext">▶︎</button>
  </span>
  <label id="timingTolWrap" data-lbl="timingTol">
    <input id="timingTol" type="range" min="10" max="200" step="1" value="60">
    <span id="timingTolVal">±60 ms</span>
  </label>
  <label id="holdTolWrap" data-lbl="holdTol">
    <input id="holdTol" type="range" min="50" max="120" step="1" value="90">
    <span id="holdTolVal">90%</span>
  </label>
  <label id="ringLookaheadWrap" data-lbl="ringLookahead">
    <input id="ringLookahead" type="range" min="1" max="6" step="0.1" value="2.5">
    <span id="ringLookaheadVal">2.5 s</span>
  </label>
  <label id="ringAlphaWrap" data-lbl="ringAlpha">
    <input id="ringAlpha" type="range" min="10" max="100" step="1" value="70">
    <span id="ringAlphaVal">70%</span>
  </label>

  <span id="info">idle</span>
  <span id="midiStat" style="min-width:280px">MIDI: 未初期化</span>
  <span id="midiLast">最後: –</span>
  <span id="fileInfo">file: –</span>
  <span id="trainerStat">step: –</span>
</div>

<canvas id="cv"></canvas>

<script>
/* ===== UI scaling ===== */
// iPhoneでUIが縮みすぎないようにスケール調整する
const isIPhone = /iPhone/i.test(navigator.userAgent);
if (isIPhone) {
  document.documentElement.style.setProperty('--ui-scale', '0.75');
  document.body.classList.add('ios');
}

/* ===== Canvas ===== */
// メインキャンバスの初期化とリサイズ処理
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
// ウィンドウの大きさに応じてキャンバスをリサイズし、Retina解像度にも対応
function resize(){ cv.width = innerWidth*devicePixelRatio; cv.height = innerHeight*devicePixelRatio; }
addEventListener('resize', resize); resize();

/* ===== Music constants ===== */
// 周波数と描画範囲に関する定数群
const F_LOW = 27.5, F_HIGH = 4186.009;
const OCTAVES = Math.ceil(Math.log2(F_HIGH/F_LOW));
const MARGIN = 80;                               // 余白を広めに
const ANG0 = Math.PI/2;                          // Cを上（0°相当）
const GRAV_ABS = ANG0;                           // 重力方向=0°固定
const EXCLUDE_PAD_RAD = 0.1 * Math.PI / 180;       // 無効領域+0.1°
const LABEL_ENH = {0:"C",1:"C#/Db",2:"D",3:"D#/Eb",4:"E",5:"F",6:"F#/Gb",7:"G",8:"G#/Ab",9:"A",10:"A#/Bb",11:"B"};
// 完全5度圏の配置を事前計算しておく
const FIFTH_ORDER_PCS = (()=>{ let a=[],pc=0; for(let k=0;k<12;k++){ a.push(pc); pc=(pc+7)%12; } return a; })();
const FIFTH_INDEX = (()=>{ const m=Array(12).fill(0); FIFTH_ORDER_PCS.forEach((pc,i)=>m[pc]=i); return m; })();
const FIFTH_LABELS = FIFTH_ORDER_PCS.map(pc=>LABEL_ENH[pc]);
const NOTE_BG = {0:[191,28,28],1:[191,109,28],2:[191,191,28],3:[109,191,28],4:[28,191,28],5:[28,191,109],6:[28,191,191],7:[28,109,191],8:[28,28,191],9:[109,28,191],10:[191,28,191],11:[191,28,109]};

/* ===== UI refs ===== */
// UI要素の参照をまとめて保持
const uiPanel = document.getElementById('ui');
const uiToggle = document.getElementById('uiToggle');
const diskLockBtn = document.getElementById('diskLock');
const anchorSel = document.getElementById('anchor');
const devWrap = document.getElementById('devWrap');
const midiDev = document.getElementById('midiDev');
const allWrap = document.getElementById('allWrap');
const midiAll = document.getElementById('midiAll');
const liveMon = document.getElementById('liveMon');
const resetBtn = document.getElementById('resetSettings');
const presetWrap = document.getElementById('presetWrap');
const presetSlotSel = document.getElementById('presetSlot');
const savePresetBtn = document.getElementById('savePreset');
const loadPresetBtn = document.getElementById('loadPreset');

const excludeSel = document.getElementById('exclude');
const uiopSlider = document.getElementById('uiop'); const uiopVal = document.getElementById('uiopVal');
const massSlider = document.getElementById('mass'); const massVal = document.getElementById('massVal');
const dampSlider = document.getElementById('damp'); const dampVal = document.getElementById('dampVal');
const snapAlphaCheckbox = document.getElementById('snapAlpha');
const info = document.getElementById('info');
const midiStat = document.getElementById('midiStat'); const midiLast = document.getElementById('midiLast');
const lowCutSlider = document.getElementById('lowCut'); const lowCutVal = document.getElementById('lowCutVal');
const highCutSlider = document.getElementById('highCut'); const highCutVal = document.getElementById('highCutVal');
const lineASlider = document.getElementById('lineA'); const lineAVal = document.getElementById('lineAVal');
const straightLineASlider = document.getElementById('straightLineA'); const straightLineAVal = document.getElementById('straightLineAVal');
const noteGuideASlider = document.getElementById('noteGuideA'); const noteGuideAVal = document.getElementById('noteGuideAVal');
const noteGuideLabelASlider = document.getElementById('noteGuideLabelA'); const noteGuideLabelAVal = document.getElementById('noteGuideLabelAVal');
const waterASlider = document.getElementById('waterA'); const waterAVal = document.getElementById('waterAVal');
const labelSizeSlider = document.getElementById('labelSize'); const labelSizeVal = document.getElementById('labelSizeVal');
const labelBGSlider = document.getElementById('labelBG'); const labelBGVal = document.getElementById('labelBGVal');
const labelAlphaSlider = document.getElementById('labelAlpha'); const labelAlphaVal = document.getElementById('labelAlphaVal');
const movNumASlider = document.getElementById('movNumA'); const movNumAVal = document.getElementById('movNumAVal');
const movNumSizeSlider = document.getElementById('movNumSize'); const movNumSizeVal = document.getElementById('movNumSizeVal');

const omegaMaxSlider = document.getElementById('omegaMax'); const omegaMaxVal = document.getElementById('omegaMaxVal');

const midiFileInput = document.getElementById('midiFile');
const fileOp = document.getElementById('fileOp');
const trainerModeWrap = document.getElementById('trainerModeWrap');
const trainerModeSel = document.getElementById('trainerMode');
const btnPlay = document.getElementById('btnPlay');
const btnPause = document.getElementById('btnPause');
const btnStop = document.getElementById('btnStop');
const btnStartTrain = document.getElementById('btnStartTrain');
const btnPrev = document.getElementById('btnPrev');
const btnNext = document.getElementById('btnNext');
const fileInfo = document.getElementById('fileInfo');
const trainerStat = document.getElementById('trainerStat');
const timingTolWrap = document.getElementById('timingTolWrap');
const timingTolSlider = document.getElementById('timingTol');
const timingTolVal = document.getElementById('timingTolVal');
const holdTolWrap = document.getElementById('holdTolWrap');
const holdTolSlider = document.getElementById('holdTol');
const holdTolVal = document.getElementById('holdTolVal');
const ringLookaheadWrap = document.getElementById('ringLookaheadWrap');
const ringLookaheadSlider = document.getElementById('ringLookahead');
const ringLookaheadVal = document.getElementById('ringLookaheadVal');
const ringAlphaWrap = document.getElementById('ringAlphaWrap');
const ringAlphaSlider = document.getElementById('ringAlpha');
const ringAlphaVal = document.getElementById('ringAlphaVal');
const transposeSlider = document.getElementById('transpose');
const transposeVal = document.getElementById('transposeVal');
const seekSlider = document.getElementById('seek');
const seekTime = document.getElementById('seekTime');

function reserveValueWidths(){
  const reserve = (el, samples)=>{
    if(!el || !samples || !samples.length) return;
    const probe = document.createElement('span');
    probe.style.visibility = 'hidden';
    probe.style.position = 'absolute';
    probe.style.whiteSpace = 'pre';
    probe.style.font = 'inherit';
    probe.style.fontVariantNumeric = 'tabular-nums';
    uiPanel.appendChild(probe);
    let maxWidth = 0;
    for(const text of samples){
      probe.textContent = text;
      const w = probe.getBoundingClientRect().width;
      if(w > maxWidth) maxWidth = w;
    }
    uiPanel.removeChild(probe);
    el.style.display = 'inline-block';
    el.style.minWidth = `${Math.ceil(maxWidth)}px`;
    el.style.textAlign = 'right';
    el.style.fontVariantNumeric = 'tabular-nums';
  };

  reserve(omegaMaxVal, ['0.0100 rad/s', '100 rad/s']);
  reserve(dampVal, ['0%/s', '99%/s']);
  reserve(uiopVal, ['100%']);
  reserve(massVal, ['M=0.01', 'M=100.00']);
  reserve(lowCutVal, [formatCutValueForLang(0, 'ja'), formatCutValueForLang(6, 'ja'), formatCutValueForLang(6, 'en'), formatCutValueForLang(6, 'es-MX'), formatCutValueForLang(6, 'pt-BR'), formatCutValueForLang(6, 'zh')]);
  reserve(highCutVal, [formatCutValueForLang(0, 'ja'), formatCutValueForLang(6, 'ja'), formatCutValueForLang(6, 'en'), formatCutValueForLang(6, 'es-MX'), formatCutValueForLang(6, 'pt-BR'), formatCutValueForLang(6, 'zh')]);
  const pctSamples = ['0%', '100%'];
  reserve(lineAVal, pctSamples);
  reserve(straightLineAVal, pctSamples);
  reserve(noteGuideAVal, pctSamples);
  reserve(noteGuideLabelAVal, pctSamples);
  reserve(waterAVal, pctSamples);
  reserve(movNumAVal, pctSamples);
  reserve(labelBGVal, pctSamples);
  reserve(labelAlphaVal, pctSamples);
  reserve(movNumSizeVal, ['10px', '60px']);
  reserve(labelSizeVal, ['8px', '36px']);
  reserve(timingTolVal, ['±10 ms', '±200 ms']);
  reserve(holdTolVal, ['50%', '120%']);
  reserve(ringLookaheadVal, ['1.0 s', '6.0 s']);
  reserve(ringAlphaVal, ['10%', '100%']);
}

/* ===== i18n + persist ===== */
// 言語切り替え用の辞書データ
const I18N = {
  en:{
    language:"language", device:"device", allInputs:"All inputs",
    anchor:"anchor", waterFixed:"water fixed", diskFixed:"disk fixed",
    liveSound:"monitor live MIDI",
    torqueExclude:"Torque exclusion", filled:"filled", unfilled:"unfilled",
    uiOpacity:"UI opacity", diskMass:"disk mass", damping:"damping",
    snapZeroAlpha:"zero ω when α=0",
    lineAlpha:"line α", straightLineAlpha:"straight lines α", noteGuideAlpha:"note guide α", noteGuideLabelAlpha:"note guide numbers α", waterAlpha:"water α", movNumAlpha:"degree numbers α", movNumSize:"degree numbers size",
    labelSize:"label size", labelBG:"label bg α", labelAlpha:"label text α",
    lowCut:"low cut (oct)", highCut:"high cut (oct)",
    omegaMax:"ω max",
    midiNotInit:"MIDI: not initialized", last:"last:", idle:"idle",
    midiNeedSecure:"need HTTPS/localhost", midiUnsupported:"unsupported",
    midiReady:"ready", midiInitFailed:"init failed", midiAllInputsStat:"all inputs",
    midiInputStatPrefix:"input:", midiNoDevice:"no device",
    midiFile:"MIDI file", fileOp:"operation", play:"playback", train:"trainer",
    trainerMode:"trainer mode", trainerModeGate:"chord gate", trainerModeRealtime:"real-time (ring)",
    trainStart:"start / restart", transpose:"transpose",
    seek:"position",
    timingTol:"timing window", holdTol:"hold target", ringLookahead:"ring lookahead", ringAlpha:"ring opacity",
    resetDefaults:"reset settings",
    presetSlot:"preset slot", presetSave:"save to slot", presetLoad:"load slot",
    presetSaved:"preset saved", presetLoaded:"preset loaded", presetEmpty:"slot is empty",
    presetSaveFailed:"save failed",
    uiHide:"hide UI", uiShow:"show UI",
    octaveSuffix:"oct", transposeSuffix:"st",
    filePlayback:"file playback", trainerStepPrefix:"step:"
    , diskLock:"lock disk", diskUnlock:"unlock disk"
  },
  "pt-BR":{
    language:"idioma", device:"dispositivo", allInputs:"todas as entradas",
    anchor:"ancoragem", waterFixed:"fixo à água", diskFixed:"fixo ao disco",
    liveSound:"monitorar áudio do MIDI de entrada",
    torqueExclude:"área sem torque", filled:"preenchido", unfilled:"não preenchido",
    uiOpacity:"opacidade da UI", diskMass:"massa do disco", damping:"amortecimento",
    snapZeroAlpha:"zerar ω quando α=0",
    lineAlpha:"α das curvas", straightLineAlpha:"α das linhas retas", noteGuideAlpha:"α do guia de notas", noteGuideLabelAlpha:"α dos números do guia", waterAlpha:"α da água", movNumAlpha:"α dos números móveis de dó", movNumSize:"tamanho dos números móveis de dó",
    labelSize:"tamanho do rótulo", labelBG:"α do fundo do rótulo", labelAlpha:"α do nome da nota",
    lowCut:"corte de graves (oit)", highCut:"corte de agudos (oit)",
    omegaMax:"ω máx",
    midiNotInit:"MIDI: não inicializado", last:"último:", idle:"ocioso",
    midiNeedSecure:"requer HTTPS/localhost", midiUnsupported:"não compatível",
    midiReady:"pronto", midiInitFailed:"falha na inicialização", midiAllInputsStat:"todas as entradas",
    midiInputStatPrefix:"entrada:", midiNoDevice:"nenhum dispositivo",
    midiFile:"arquivo MIDI", fileOp:"operação", play:"reprodução", train:"treinador",
    trainerMode:"modo do treinador", trainerModeGate:"acorde por acorde", trainerModeRealtime:"tempo real (anel)",
    trainStart:"iniciar/reiniciar", transpose:"transposição",
    seek:"posição de reprodução",
    timingTol:"janela de tempo", holdTol:"duração alvo", ringLookahead:"antevisão no anel", ringAlpha:"opacidade do anel",
    resetDefaults:"restaurar padrões",
    presetSlot:"slot de preset", presetSave:"salvar no slot", presetLoad:"carregar slot",
    presetSaved:"preset salvo", presetLoaded:"preset carregado", presetEmpty:"slot vazio",
    presetSaveFailed:"falha ao salvar",
    uiHide:"ocultar UI", uiShow:"mostrar UI",
    octaveSuffix:"oit", transposeSuffix:"semitons",
    filePlayback:"reprodução de arquivo", trainerStepPrefix:"etapa:"
    , diskLock:"travar disco", diskUnlock:"destravar disco"
  },
  "es-MX":{
    language:"idioma", device:"dispositivo", allInputs:"todas las entradas",
    anchor:"fijación", waterFixed:"agua fija", diskFixed:"disco fijo",
    liveSound:"reproducir audio MIDI de entrada",
    torqueExclude:"zona excluida de torque", filled:"relleno", unfilled:"sin rellenar",
    uiOpacity:"opacidad de la UI", diskMass:"masa del disco", damping:"amortiguación",
    snapZeroAlpha:"detener ω cuando α=0",
    lineAlpha:"opacidad de curvas", straightLineAlpha:"opacidad de líneas rectas", noteGuideAlpha:"opacidad de la guía de notas", noteGuideLabelAlpha:"opacidad de números guía", waterAlpha:"opacidad del agua", movNumAlpha:"opacidad de números móviles do", movNumSize:"tamaño de números móviles do",
    labelSize:"tamaño de etiqueta", labelBG:"opacidad del fondo de la etiqueta", labelAlpha:"opacidad del nombre de nota",
    lowCut:"corte de graves", highCut:"corte de agudos",
    omegaMax:"ω máx",
    midiNotInit:"MIDI: sin inicializar", last:"último:", idle:"en espera",
    midiNeedSecure:"requiere HTTPS/localhost", midiUnsupported:"no compatible",
    midiReady:"listo", midiInitFailed:"fallo de inicio", midiAllInputsStat:"todas las entradas",
    midiInputStatPrefix:"entrada:", midiNoDevice:"sin dispositivo",
    midiFile:"archivo MIDI", fileOp:"operación", play:"reproducción", train:"entrenador",
    trainerMode:"modo de entrenador", trainerModeGate:"acorde por acorde", trainerModeRealtime:"tiempo real (anillo)",
    trainStart:"iniciar/reiniciar", transpose:"transposición",
    seek:"posición de reproducción",
    timingTol:"ventana de tiempo", holdTol:"duración objetivo", ringLookahead:"anticipación del anillo", ringAlpha:"opacidad del anillo",
    resetDefaults:"restablecer ajustes",
    presetSlot:"ranura de preset", presetSave:"guardar en ranura", presetLoad:"cargar ranura",
    presetSaved:"preset guardado", presetLoaded:"preset cargado", presetEmpty:"ranura vacía",
    presetSaveFailed:"error al guardar",
    uiHide:"ocultar UI", uiShow:"mostrar UI",
    octaveSuffix:"oct.", transposeSuffix:"semitonos",
    filePlayback:"reproducción de archivo", trainerStepPrefix:"paso:",
    diskLock:"bloquear disco", diskUnlock:"desbloquear disco"
  },
  ja:{
    language:"言語", device:"デバイス", allInputs:"全入力",
    anchor:"固定", waterFixed:"水面固定", diskFixed:"ディスク固定",
    liveSound:"MIDI入力の音声再生",
    torqueExclude:"トルク無効領域", filled:"塗りつぶし", unfilled:"非塗りつぶし",
    uiOpacity:"UI不透明度", diskMass:"ディスク質量", damping:"ダンピング",
    snapZeroAlpha:"α=0で角速度を停止",
    lineAlpha:"曲線の不透明度", straightLineAlpha:"直線の不透明度", noteGuideAlpha:"音ガイドの不透明度", noteGuideLabelAlpha:"音ガイド数字の不透明度", waterAlpha:"水面の不透明度", movNumAlpha:"移動ド数字の不透明度", movNumSize:"移動ド数字サイズ",
    labelSize:"ラベルサイズ", labelBG:"ラベル背景の不透明度", labelAlpha:"音名の不透明度",
    lowCut:"低音域カット", highCut:"高音域カット",
    omegaMax:"最大回転速度",
    midiNotInit:"MIDI: 未初期化", last:"最後:", idle:"待機",
    midiNeedSecure:"HTTPS/localhostが必要", midiUnsupported:"未対応",
    midiReady:"準備完了", midiInitFailed:"初期化失敗", midiAllInputsStat:"全入力",
    midiInputStatPrefix:"入力:", midiNoDevice:"デバイスなし",
    midiFile:"MIDIファイル", fileOp:"操作", play:"再生", train:"トレーナー",
    trainerMode:"トレーナーモード", trainerModeGate:"和音ゲート", trainerModeRealtime:"リアルタイム（リング）",
    trainStart:"開始/リスタート", transpose:"移調",
    seek:"再生位置",
    timingTol:"タイミング許容", holdTol:"長さ目標", ringLookahead:"リング先読み", ringAlpha:"リング不透明度",
    resetDefaults:"初期設定に戻す",
    presetSlot:"プリセット枠", presetSave:"枠に保存", presetLoad:"枠を読み込み",
    presetSaved:"プリセットを保存しました", presetLoaded:"プリセットを読み込みました", presetEmpty:"枠が空です",
    presetSaveFailed:"保存に失敗しました",
    uiHide:"UI隠す", uiShow:"UI表示",
    octaveSuffix:"オクターブ", transposeSuffix:"半音",
    filePlayback:"ファイル再生", trainerStepPrefix:"ステップ:",
    diskLock:"円盤ロック", diskUnlock:"ロック解除"
  },
  ko:{
    language:"언어", device:"장치", allInputs:"모든 입력",
    anchor:"고정", waterFixed:"수면 고정", diskFixed:"디스크 고정",
    liveSound:"MIDI 입력 음성 재생",
    torqueExclude:"토크 제외 영역", filled:"채움", unfilled:"비채움",
    uiOpacity:"UI 불투명도", diskMass:"디스크 질량", damping:"댐핑",
    snapZeroAlpha:"α=0에서 각속도 정지",
    lineAlpha:"곡선 불투명도", straightLineAlpha:"직선 불투명도", noteGuideAlpha:"음 가이드 불투명도", noteGuideLabelAlpha:"음 가이드 숫자 불투명도", waterAlpha:"수면 불투명도", movNumAlpha:"이동 도 숫자 불투명도", movNumSize:"이동 도 숫자 크기",
    labelSize:"라벨 크기", labelBG:"라벨 배경 불투명도", labelAlpha:"음 이름 불투명도",
    lowCut:"저음역 컷", highCut:"고음역 컷",
    omegaMax:"최대 회전 속도",
    midiNotInit:"MIDI: 초기화되지 않음", last:"마지막:", idle:"대기",
    midiNeedSecure:"HTTPS/localhost 필요", midiUnsupported:"미지원",
    midiReady:"준비 완료", midiInitFailed:"초기화 실패", midiAllInputsStat:"모든 입력",
    midiInputStatPrefix:"입력:", midiNoDevice:"장치 없음",
    midiFile:"MIDI 파일", fileOp:"동작", play:"재생", train:"트레이너",
    trainerMode:"트레이너 모드", trainerModeGate:"화음 게이트", trainerModeRealtime:"실시간(링)",
    trainStart:"시작/재시작", transpose:"이조",
    seek:"재생 위치",
    timingTol:"타이밍 허용", holdTol:"길이 목표", ringLookahead:"링 미리보기", ringAlpha:"링 불투명도",
    resetDefaults:"초기 설정으로",
    presetSlot:"프리셋 슬롯", presetSave:"슬롯에 저장", presetLoad:"슬롯 불러오기",
    presetSaved:"프리셋을 저장했습니다", presetLoaded:"프리셋을 불러왔습니다", presetEmpty:"슬롯이 비어 있습니다",
    presetSaveFailed:"저장에 실패했습니다",
    uiHide:"UI 숨기기", uiShow:"UI 표시",
    octaveSuffix:"옥타브", transposeSuffix:"반음",
    filePlayback:"파일 재생", trainerStepPrefix:"스텝:",
    diskLock:"디스크 잠금", diskUnlock:"잠금 해제"
  },
  zh:{
    language:"语言", device:"设备", allInputs:"全部输入",
    anchor:"固定", waterFixed:"水面固定", diskFixed:"盘面固定",
    liveSound:"播放MIDI输入音频",
    torqueExclude:"扭矩排除区域", filled:"填充", unfilled:"空心",
    uiOpacity:"界面不透明度", diskMass:"盘质量", damping:"阻尼",
    snapZeroAlpha:"α=0 时停止角速度",
    lineAlpha:"曲线不透明度", straightLineAlpha:"直线不透明度", noteGuideAlpha:"音符指引不透明度", noteGuideLabelAlpha:"音符指引数字不透明度", waterAlpha:"水面不透明度", movNumAlpha:"移动do数字不透明度", movNumSize:"移动do数字大小",
    labelSize:"标签大小", labelBG:"标签背景不透明度", labelAlpha:"音名不透明度",
    lowCut:"低频削减", highCut:"高频削减",
    omegaMax:"最大角速度",
    midiNotInit:"MIDI：未初始化", last:"最后:", idle:"空闲",
    midiNeedSecure:"需要 HTTPS/localhost", midiUnsupported:"不支持",
    midiReady:"已准备", midiInitFailed:"初始化失败", midiAllInputsStat:"全部输入",
    midiInputStatPrefix:"输入:", midiNoDevice:"无设备",
    midiFile:"MIDI 文件", fileOp:"操作", play:"播放", train:"训练器",
    trainerMode:"训练模式", trainerModeGate:"和弦闯关", trainerModeRealtime:"实时（环形）",
    trainStart:"开始/重新开始", transpose:"移调",
    seek:"播放位置",
    timingTol:"时序容差", holdTol:"按住时长目标", ringLookahead:"环形预览", ringAlpha:"环形不透明度",
    resetDefaults:"恢复默认设置",
    presetSlot:"预设槽位", presetSave:"保存到槽位", presetLoad:"加载槽位",
    presetSaved:"预设已保存", presetLoaded:"预设已加载", presetEmpty:"槽位为空",
    presetSaveFailed:"保存失败",
    uiHide:"隐藏界面", uiShow:"显示界面",
    octaveSuffix:"八度", transposeSuffix:"半音",
    filePlayback:"文件播放", trainerStepPrefix:"步骤:",
    diskLock:"锁定圆盘", diskUnlock:"解除锁定"
  }
};

reserveValueWidths();
const SETTINGS_KEY = 'ppm:v6';
const PRESET_SLOT_COUNT = 3;
const presetStorageKey = slot => `${SETTINGS_KEY}:preset${slot}`;
const clampPresetSlot = value => {
  const parsed = parseInt(value,10);
  if(Number.isNaN(parsed)) return 1;
  return Math.max(1, Math.min(PRESET_SLOT_COUNT, parsed));
};
// 初回ロード時のデフォルト設定をキャッシュ
let DEFAULT_SETTINGS = null;

// UIスケールと初期言語
let uiScale = 0.95;
const SUPPORTED_LANGS = ['en','pt-BR','es-MX','ja','ko','zh'];
const navigatorLang = (navigator.language || 'en').toLowerCase();
let lang = navigatorLang.startsWith('ja') ? 'ja'
  : navigatorLang.startsWith('ko') ? 'ko'
  : navigatorLang.startsWith('zh') ? 'zh'
  : navigatorLang.startsWith('pt') ? 'pt-BR'
  : navigatorLang.startsWith('es') ? 'es-MX'
  : 'en';
let midiTranspose = 0;
function t(k){ return (I18N[lang]&&I18N[lang][k]) || I18N.en[k] || k; }
// ラベル要素に翻訳済みテキストを設定
function setLabelText(labelEl, key){
  if(!labelEl) return;
  if(labelEl.firstChild && labelEl.firstChild.nodeType===Node.TEXT_NODE){
    labelEl.firstChild.nodeValue = t(key)+' ';
  }else{
    labelEl.prepend(document.createTextNode(t(key)+' '));
  }
}
// HTML全体のCSSカスタムプロパティに反映してUIのサイズを切り替える
function applyUIScale(){ document.documentElement.style.setProperty('--ui-scale', uiScale); }
function formatCutValueForLang(value, targetLang){
  const suffix = (I18N[targetLang] && I18N[targetLang].octaveSuffix) || I18N.en.octaveSuffix;
  return `${value} ${suffix}`;
}
function updatePresetOptions(){
  if(!presetSlotSel) return;
  const current = clampPresetSlot(presetSlotSel.value || 1);
  presetSlotSel.innerHTML = '';
  for(let i=1;i<=PRESET_SLOT_COUNT;i++){
    const opt = document.createElement('option');
    opt.value = String(i);
    opt.textContent = `${t('presetSlot')} ${i}`;
    presetSlotSel.appendChild(opt);
  }
  presetSlotSel.value = String(current);
}
// ラベルやステータスの文言を現在の言語設定で書き換える
function applyI18N(){
  document.documentElement.lang = lang;
  reserveValueWidths();
  // data-lbl属性を持つすべての要素に翻訳済みの文字列を注入
  document.querySelectorAll('[data-lbl]').forEach(el=> setLabelText(el, el.getAttribute('data-lbl')));
  updatePresetOptions();
  if(savePresetBtn) savePresetBtn.textContent = t('presetSave');
  if(loadPresetBtn) loadPresetBtn.textContent = t('presetLoad');
  anchorSel.querySelector('option[value="water"]').textContent = t('waterFixed');
  anchorSel.querySelector('option[value="disk"]').textContent  = t('diskFixed');
  excludeSel.querySelector('option[value="filled"]').textContent   = t('filled');
  excludeSel.querySelector('option[value="unfilled"]').textContent = t('unfilled');
  fileOp.querySelector('option[value="play"]').textContent = t('play');
  fileOp.querySelector('option[value="train"]').textContent = t('train');
  trainerModeSel.querySelector('option[value="gate"]').textContent = t('trainerModeGate');
  trainerModeSel.querySelector('option[value="realtime"]').textContent = t('trainerModeRealtime');
  btnStartTrain.textContent = t('trainStart');
  if(resetBtn) resetBtn.textContent = t('resetDefaults');
  uiToggle.textContent = uiVisible ? t('uiHide') : t('uiShow');
  updateDiskLockUI();
  updateCutDisplays();
  updateTransposeDisplay();
  document.getElementById('lang').value = lang;
  info.textContent = t('idle');
  midiStat.textContent = t('midiNotInit');
  midiLast.textContent = t('last') + ' –';
  updateFileOpUI();
}
// 言語選択ドロップダウンの変更ハンドラ
document.getElementById('lang').addEventListener('change', e=>{
  lang = SUPPORTED_LANGS.includes(e.target.value) ? e.target.value : 'en';
  applyI18N(); saveSettings();
});

// UIの状態をオブジェクトにまとめて保存用に返す
function collectSettingsFromUI(){
  // 保存対象のプロパティを列挙
  return {
    lang, uiScale,
    anchor: anchorSel.value, midiAll: midiAll.checked, liveMon: liveMon.checked,
    uiop: uiopSlider.value, mass: massSlider.value,
    lineA: lineASlider.value, straightLineA: straightLineASlider.value, waterA: waterASlider.value,
    noteGuideA: noteGuideASlider.value,
    noteGuideLabelA: noteGuideLabelASlider.value,
    movNumA: movNumASlider.value, movNumSize: movNumSizeSlider.value,
    labelSize: labelSizeSlider.value, labelBG: labelBGSlider.value,
    labelAlpha: labelAlphaSlider.value,
    exclude: excludeSel.value,
    lowCut: lowCutOct,
    highCut: highCutOct,
    omegaMaxExp: omegaMaxSlider.value,
    midiTranspose,
    dampPct: dampSlider.value,
    snapZeroAlpha: snapAlphaCheckbox.checked,
    fileOp: fileOp.value,
    trainerMode,
    timingToleranceMs,
    holdTolerancePct,
    ringLookaheadSec,
    ringAlpha,
    uiHidden: !uiVisible,
    diskLocked
  };
}

// localStorageへ設定を保存（例外は握りつぶす）
function saveSettings(){
  try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectSettingsFromUI())); }catch{}
}
// 保存された設定をUIに反映する
function applySettings(settings, {force = false} = {}){
  const s = (settings && typeof settings === 'object') ? settings : {};
  const has = key => force ? (key in s) : (s[key] != null);

  // 言語関連の復元
  if(has('lang')){
    lang = SUPPORTED_LANGS.includes(s.lang) ? s.lang : 'en';
  }
  // UIスケール関連の復元
  if(has('uiScale')){
    const parsed = parseFloat(s.uiScale);
    if(!Number.isNaN(parsed)) uiScale = parsed;
  }
  // ここから下は順番依存のため見通しを良くするため小分けにコメントを挿入
  // アンカーやMIDI関連の復元
  if(has('anchor') && s.anchor){
    anchorSel.value = s.anchor;
  }
  if(has('midiAll')){
    midiAll.checked = !!s.midiAll;
  }
  if(has('liveMon')){
    liveMon.checked = !!s.liveMon;
  }
  // 視覚設定の値を順番に反映
  if(has('uiop')){
    uiopSlider.value = s.uiop;
    applyUIOpacity();
  }
  if(has('mass')){
    massSlider.value = s.mass;
    updateMass();
  }
  if(has('lineA')){
    lineASlider.value = s.lineA;
    lineASlider.oninput();
  }
  if(has('straightLineA')){
    straightLineASlider.value = s.straightLineA;
    straightLineASlider.oninput();
  }
  if(has('waterA')){
    waterASlider.value = s.waterA;
    waterASlider.oninput();
  }
  if(has('noteGuideA')){
    noteGuideASlider.value = s.noteGuideA;
    noteGuideASlider.oninput();
  }
  if(has('noteGuideLabelA')){
    noteGuideLabelASlider.value = s.noteGuideLabelA;
    noteGuideLabelASlider.oninput();
  }
  if(has('movNumA')){
    movNumASlider.value = s.movNumA;
    movNumASlider.oninput();
  }
  if(has('movNumSize')){
    movNumSizeSlider.value = s.movNumSize;
    movNumSizeSlider.oninput();
  }
  if(has('labelSize')){
    labelSizeSlider.value = s.labelSize;
    labelSizeSlider.oninput();
  }
  if(has('labelBG')){
    labelBGSlider.value = s.labelBG;
    labelBGSlider.oninput();
  }
  if(has('labelAlpha')){
    labelAlphaSlider.value = s.labelAlpha;
    labelAlphaSlider.oninput();
  }
  if(has('exclude')){
    excludeSel.value = s.exclude;
  }
  if(has('lowCut')){
    // 入力値は整数として扱い、NaNなら0に戻す
    const value = parseInt(s.lowCut,10);
    applyLowCut(Number.isNaN(value) ? 0 : value, false);
  }
  if(has('highCut')){
    // 高域の制限も同様に安全な範囲へクランプ
    const value = parseInt(s.highCut,10);
    applyHighCut(Number.isNaN(value) ? 0 : value, false);
  }
  if(has('omegaMaxExp')){
    omegaMaxSlider.value = s.omegaMaxExp;
    applyOmegaMaxFromSlider();
  }
  if(has('midiTranspose')){
    const value = parseInt(s.midiTranspose,10);
    const clamped = Math.max(-6, Math.min(6, Number.isNaN(value) ? 0 : value));
    midiTranspose = clamped;
    transposeSlider.value = String(clamped);
    applyTransposeSetting({shouldSave:false, preservePlayback:false});
  }
  if(has('dampPct')){
    dampSlider.value = s.dampPct;
  }else if(!force && s.dampExp!=null){
    const exp = parseFloat(s.dampExp);
    if(!Number.isNaN(exp)){
      const q = Math.min(99, Math.max(0.001, Math.pow(10, exp)));
      const p = 100 - q;
      dampSlider.value = Math.min(99, Math.max(0, p));
    }
  }
  if(has('snapZeroAlpha')){
    snapAlphaCheckbox.checked = !!s.snapZeroAlpha;
  }
  if(has('fileOp')){
    fileOp.value = s.fileOp;
  }
  if(has('trainerMode')){
    trainerMode = s.trainerMode === 'realtime' ? 'realtime' : 'gate';
    trainerModeSel.value = trainerMode;
  }
  if(has('timingToleranceMs')){
    const v = parseInt(s.timingToleranceMs,10);
    if(!Number.isNaN(v)){
      timingToleranceMs = v;
      timingTolSlider.value = String(v);
      timingTolVal.textContent = `±${v} ms`;
    }
  }
  if(has('holdTolerancePct')){
    const v = parseInt(s.holdTolerancePct,10);
    if(!Number.isNaN(v)){
      holdTolerancePct = v;
      holdTolSlider.value = String(v);
      holdTolVal.textContent = `${v}%`;
    }
  }
  if(has('ringLookaheadSec')){
    const v = parseFloat(s.ringLookaheadSec);
    if(!Number.isNaN(v)){
      ringLookaheadSec = v;
      ringLookaheadSlider.value = String(v);
      ringLookaheadVal.textContent = `${v.toFixed(1)} s`;
    }
  }
  if(has('ringAlpha')){
    const v = parseFloat(s.ringAlpha);
    if(!Number.isNaN(v)){
      ringAlpha = v;
      ringAlphaSlider.value = String(Math.round(v*100));
      ringAlphaVal.textContent = `${Math.round(v*100)}%`;
    }
  }
  if(has('diskLocked')){
    diskLocked = !!s.diskLocked;
  }
  if(has('uiHidden')){
    uiVisible = !s.uiHidden;
    updateUIVisibility();
  }
}
function finalizeAppliedSettings({shouldConnectMIDI = false} = {}){
  applyUIScale();
  applyI18N();
  snapZeroAlpha = snapAlphaCheckbox.checked;
  updateDampFromSlider();
  updateFileOpUI();
  if(shouldConnectMIDI) connectMIDIAccordingToUI();
}

function loadSettings(){
  let stored = {};
  try{
    // localStorageから設定文字列を取得し、壊れていてもアプリが落ちないようにする
    stored = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}') || {};
  }catch{}
  applySettings(stored);
  finalizeAppliedSettings();
}

function selectedPresetSlot(){
  return clampPresetSlot(presetSlotSel ? presetSlotSel.value : 1);
}

function savePreset(slot){
  const target = clampPresetSlot(slot);
  try{
    localStorage.setItem(presetStorageKey(target), JSON.stringify(collectSettingsFromUI()));
    info.textContent = `${t('presetSaved')} #${target}`;
  }catch{
    info.textContent = t('presetSaveFailed');
  }
}

function loadPreset(slot){
  const target = clampPresetSlot(slot);
  let storedPreset = null;
  try{
    storedPreset = JSON.parse(localStorage.getItem(presetStorageKey(target)) || 'null');
  }catch{}
  if(!storedPreset){
    info.textContent = t('presetEmpty');
    return;
  }
  applySettings(storedPreset, {force:true});
  finalizeAppliedSettings({shouldConnectMIDI:true});
  saveSettings();
  info.textContent = `${t('presetLoaded')} #${target}`;
}

if(presetSlotSel){
  presetSlotSel.addEventListener('change', ()=>{
    presetSlotSel.value = String(selectedPresetSlot());
  });
}
if(savePresetBtn){
  savePresetBtn.onclick = ()=> savePreset(selectedPresetSlot());
}
if(loadPresetBtn){
  loadPresetBtn.onclick = ()=> loadPreset(selectedPresetSlot());
}

/* ===== UI show/hide ===== */
let uiVisible = true;
function updateUIVisibility(){
  // displayプロパティで丸ごとパネルを非表示にする
  uiPanel.style.display = uiVisible ? '' : 'none';
  uiToggle.setAttribute('aria-pressed', String(!uiVisible));
  uiToggle.textContent = uiVisible ? t('uiHide') : t('uiShow');
}
// ボタン操作時は状態をトグルして即座に保存
uiToggle.onclick = ()=>{ uiVisible = !uiVisible; updateUIVisibility(); saveSettings(); };
// キーボードショートカット（Uキー）での開閉をサポート
addEventListener('keydown', e=>{ if(e.key==='u' || e.key==='U'){ uiVisible = !uiVisible; updateUIVisibility(); saveSettings(); }});

function updateDiskLockUI(){
  if(!diskLockBtn) return;
  diskLockBtn.setAttribute('aria-pressed', String(diskLocked));
  diskLockBtn.textContent = diskLocked ? t('diskUnlock') : t('diskLock');
}
if(diskLockBtn){
  diskLockBtn.onclick = ()=>{
    diskLocked = !diskLocked;
    if(diskLocked) dragRot.active = false;
    if(!diskLocked) stopAllLockedTouches();
    updateDiskLockUI();
    saveSettings();
  };
}

/* ファイル操作UIの表示切替（再生 or トレーナー） */
function updateFileOpUI(){
  const isPlay = (fileOp.value === 'play');
  // 再生モードでは再生ボタン群、トレーナーモードでは練習用ボタン群だけを見せる
  document.getElementById('playBtns').style.display  = isPlay ? '' : 'none';
  document.getElementById('trainBtns').style.display = isPlay ? 'none' : '';
  const trainerOnly = [trainerModeWrap, timingTolWrap, holdTolWrap, ringLookaheadWrap, ringAlphaWrap];
  trainerOnly.forEach(el=>{ if(el) el.style.display = isPlay ? 'none' : ''; });
  if(isPlay){
    // 再生モード時は最新の進行状況を再生ステータスで置き換える
    info.textContent = t('filePlayback');
  }else{
    // トレーナーモードに切り替わると進捗インジケータを初期化
    trainerStat.textContent = (trainerMode === 'realtime') ? 'ring: –' : `${t('trainerStepPrefix')} –`;
  }
}
fileOp.addEventListener('change', ()=>{ updateFileOpUI(); saveSettings(); });

/* ===== Helpers ===== */
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function ringParams(){
  const half = Math.max(1, Math.min(cv.width, cv.height) / 2);
  const safeHalf = Math.max(1, half - 4);
  let rMax = half - MARGIN;
  if(!Number.isFinite(rMax)) rMax = safeHalf;
  if(rMax < 1) rMax = safeHalf;
  rMax = Math.max(1, Math.min(rMax, safeHalf));
  const octaves = activeOctaveCount();
  const minRadius = (highCutOct > 0) ? rMax * 0.1 : 0;
  const span = Math.max(0, rMax - minRadius);
  const step = octaves ? (span / octaves) : 0;
  return {rMax, step, octaves, minRadius, minFreq: minDisplayFreq(), maxFreq: maxDisplayFreq()};
}
function baseAngleFromFifthIndex(i){ return ANG0 + 2*Math.PI*(i%12)/12; }
function angleForMidiAbs(m){ const pc=((m%12)+12)%12; const idx=FIFTH_INDEX[pc]; return baseAngleFromFifthIndex(idx) + diskAngle; } // 物理用
function angleForMidiDraw(m, drawRot){ const pc=((m%12)+12)%12; const idx=FIFTH_INDEX[pc]; return baseAngleFromFifthIndex(idx) + drawRot; } // 描画用
function radiusFromFreq(f, rMax, step, minRadius = 0){
  const octaves = activeOctaveCount();
  const oc = Math.log2(f / minDisplayFreq());
  const ocClamped = Math.max(0, Math.min(octaves, oc));
  const r = rMax - step*ocClamped;
  return Math.max(minRadius, Math.min(rMax, r));
}
function polarToXY(cx,cy,r,th){ return { x: cx + r*Math.cos(th), y: cy - r*Math.sin(th) }; }
function shortestDelta(a,b){ let d=b-a; while(d> Math.PI) d-=2*Math.PI; while(d<=-Math.PI) d+=2*Math.PI; return d; }
function mergeNoteMaps(...maps){
  const merged = new Map();
  for(const m of maps){
    for(const [note, vel] of m){
      const prev = merged.get(note);
      if(prev == null || vel > prev) merged.set(note, vel);
    }
  }
  return merged;
}
// ステータス表示の更新を一元化
function updateMIDIStat(text){ midiStat.textContent = 'MIDI: ' + text; }

/* 表示系 */
let linkAlpha = parseInt(lineASlider.value,10)/100; lineAVal.textContent=`${Math.round(linkAlpha*100)}%`;
lineASlider.oninput = ()=>{ linkAlpha = parseInt(lineASlider.value,10)/100; lineAVal.textContent=`${Math.round(linkAlpha*100)}%`; saveSettings(); };

// 直線表示の不透明度をスライダーで制御
let straightLinkAlpha = parseInt(straightLineASlider.value,10)/100; straightLineAVal.textContent=`${Math.round(straightLinkAlpha*100)}%`;
straightLineASlider.oninput = ()=>{
  straightLinkAlpha = parseInt(straightLineASlider.value,10)/100;
  straightLineAVal.textContent = `${Math.round(straightLinkAlpha*100)}%`;
  saveSettings();
};

// ガイド線の可視性調整
let noteGuideAlpha = parseInt(noteGuideASlider.value,10)/100; noteGuideAVal.textContent=`${Math.round(noteGuideAlpha*100)}%`;
noteGuideASlider.oninput = ()=>{
  noteGuideAlpha = parseInt(noteGuideASlider.value,10)/100;
  noteGuideAVal.textContent = `${Math.round(noteGuideAlpha*100)}%`;
  saveSettings();
};

// ガイド番号の不透明度
let noteGuideLabelAlpha = parseInt(noteGuideLabelASlider.value,10)/100; noteGuideLabelAVal.textContent=`${Math.round(noteGuideLabelAlpha*100)}%`;
noteGuideLabelASlider.oninput = ()=>{
  noteGuideLabelAlpha = parseInt(noteGuideLabelASlider.value,10)/100;
  noteGuideLabelAVal.textContent = `${Math.round(noteGuideLabelAlpha*100)}%`;
  saveSettings();
};

// 水面表現の濃さを調整
let waterAlpha = parseInt(waterASlider.value,10)/100; waterAVal.textContent=`${Math.round(waterAlpha*100)}%`;
waterASlider.oninput = ()=>{ waterAlpha = parseInt(waterASlider.value,10)/100; waterAVal.textContent=`${Math.round(waterAlpha*100)}%`; saveSettings(); };

// 移動ド番号の表示強度
let movNumAlpha = parseInt(movNumASlider.value,10)/100; movNumAVal.textContent=`${Math.round(movNumAlpha*100)}%`;
movNumASlider.oninput = ()=>{ movNumAlpha = parseInt(movNumASlider.value,10)/100; movNumAVal.textContent=`${Math.round(movNumAlpha*100)}%`; saveSettings(); };

// 移動ド番号の文字サイズ
let movNumSizePx = parseInt(movNumSizeSlider.value,10); movNumSizeVal.textContent=`${movNumSizePx}px`;
movNumSizeSlider.oninput = ()=>{ movNumSizePx = parseInt(movNumSizeSlider.value,10); movNumSizeVal.textContent=`${movNumSizePx}px`; saveSettings(); };

// ラベル文字サイズ
let labelFontPx = parseInt(labelSizeSlider.value,10); labelSizeVal.textContent=`${labelFontPx}px`;
labelSizeSlider.oninput = ()=>{ labelFontPx = parseInt(labelSizeSlider.value,10); labelSizeVal.textContent=`${labelFontPx}px`; saveSettings(); };

// ラベル背景の透明度
let labelBgAlpha = parseInt(labelBGSlider.value,10)/100; labelBGVal.textContent=`${Math.round(labelBgAlpha*100)}%`;
labelBGSlider.oninput = ()=>{ labelBgAlpha = parseInt(labelBGSlider.value,10)/100; labelBGVal.textContent=`${Math.round(labelBgAlpha*100)}%`; saveSettings(); };

// ラベルテキストの透明度
let labelTextAlpha = parseInt(labelAlphaSlider.value,10)/100; labelAlphaVal.textContent=`${Math.round(labelTextAlpha*100)}%`;
labelAlphaSlider.oninput = ()=>{
  labelTextAlpha = parseInt(labelAlphaSlider.value,10)/100;
  labelAlphaVal.textContent = `${Math.round(labelTextAlpha*100)}%`;
  saveSettings();
};

let trainerMode = trainerModeSel.value || 'gate';
trainerModeSel.onchange = ()=>{
  trainerMode = trainerModeSel.value || 'gate';
  trainer = buildTrainerForMode();
  updateTrainerUI();
  saveSettings();
};

let timingToleranceMs = parseInt(timingTolSlider.value,10); timingTolVal.textContent = `±${timingToleranceMs} ms`;
timingTolSlider.oninput = ()=>{
  timingToleranceMs = parseInt(timingTolSlider.value,10);
  timingTolVal.textContent = `±${timingToleranceMs} ms`;
  if(trainer && trainer.kind==='realtime'){ trainer.applyOptions({toleranceMs: timingToleranceMs, holdRatio: holdTolerancePct/100, lookaheadSec: ringLookaheadSec}); }
  saveSettings();
};

let holdTolerancePct = parseInt(holdTolSlider.value,10); holdTolVal.textContent = `${holdTolerancePct}%`;
holdTolSlider.oninput = ()=>{
  holdTolerancePct = parseInt(holdTolSlider.value,10);
  holdTolVal.textContent = `${holdTolerancePct}%`;
  if(trainer && trainer.kind==='realtime'){ trainer.applyOptions({toleranceMs: timingToleranceMs, holdRatio: holdTolerancePct/100, lookaheadSec: ringLookaheadSec}); }
  saveSettings();
};

let ringLookaheadSec = parseFloat(ringLookaheadSlider.value); ringLookaheadVal.textContent = `${ringLookaheadSec.toFixed(1)} s`;
ringLookaheadSlider.oninput = ()=>{
  ringLookaheadSec = parseFloat(ringLookaheadSlider.value);
  ringLookaheadVal.textContent = `${ringLookaheadSec.toFixed(1)} s`;
  if(trainer && trainer.kind==='realtime'){ trainer.applyOptions({toleranceMs: timingToleranceMs, holdRatio: holdTolerancePct/100, lookaheadSec: ringLookaheadSec}); }
  saveSettings();
};

let ringAlpha = parseInt(ringAlphaSlider.value,10)/100; ringAlphaVal.textContent = `${Math.round(ringAlpha*100)}%`;
ringAlphaSlider.oninput = ()=>{
  ringAlpha = parseInt(ringAlphaSlider.value,10)/100;
  ringAlphaVal.textContent = `${Math.round(ringAlpha*100)}%`;
  saveSettings();
};

/* ===== Global state ===== */
let worldRot = 0;          // 描画用回転（anchorにより決定）
let diskAngle = 0, diskOmega = 0;
let diskMass = Math.pow(10, parseFloat(massSlider.value));
let excludeMode = excludeSel.value;
let midiDataRaw = null; // 未移調のMIDIデータ
let midiData = null;    // 現在の移調を反映したデータ {ppq, tempos:[...], notes:[...], lengthSec, onsets, onsetTicks}
let trainer = null;
let player = null;
let seekMuting = false;
let seekWasRunning = false;
let diskLocked = false;

function applySeekMuteState(){
  if(synth && typeof synth.setMuted === 'function') synth.setMuted(seekMuting);
  if(tapSynth && typeof tapSynth.setMuted === 'function') tapSynth.setMuted(seekMuting);
}
excludeSel.onchange = ()=>{ excludeMode = excludeSel.value; saveSettings(); };

// UIを隠したフルスクリーン表示中はスクロールできなくてもよいので、
// ディスク（anchor=disk時は水面）をドラッグで回転させる操作を用意する。
const dragRot = {
  active: false,
  startAngle: 0,
  startDiskAngle: 0,
  anchor: 'water',
  moved: false
};
function clientAngle(ev){
  const rect = cv.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const x = (ev.clientX != null) ? ev.clientX : (ev.touches && ev.touches[0] && ev.touches[0].clientX);
  const y = (ev.clientY != null) ? ev.clientY : (ev.touches && ev.touches[0] && ev.touches[0].clientY);
  if(x == null || y == null) return null;
  const dx = x - cx;
  const dy = cy - y; // 画面座標系をキャンバスの極座標に合わせる
  return Math.atan2(dy, dx);
}
function clientPolar(ev){
  const rect = cv.getBoundingClientRect();
  const cxCss = rect.left + rect.width / 2;
  const cyCss = rect.top + rect.height / 2;
  const x = (ev.clientX != null) ? ev.clientX : (ev.touches && ev.touches[0] && ev.touches[0].clientX);
  const y = (ev.clientY != null) ? ev.clientY : (ev.touches && ev.touches[0] && ev.touches[0].clientY);
  if(x == null || y == null) return null;
  const dx = (x - cxCss) * devicePixelRatio;
  const dy = (cyCss - y) * devicePixelRatio;
  return { theta: Math.atan2(dy, dx), r: Math.hypot(dx, dy) };
}
function beginDrag(ev){
  if(ev.button != null && ev.button !== 0) return;
  if(diskLocked){
    startLockedTouch(ev);
    return;
  }
  const ang = clientAngle(ev);
  if(ang == null) return;
  dragRot.active = true;
  dragRot.startAngle = ang;
  dragRot.startDiskAngle = diskAngle;
  dragRot.anchor = anchorSel.value;
  dragRot.moved = false;
  diskOmega = 0; // 手動操作中は慣性をリセット
  if(ev.pointerId != null && cv.setPointerCapture){
    try{ cv.setPointerCapture(ev.pointerId); }catch{}
  }
  ev.preventDefault();
}
function moveDrag(ev){
  if(diskLocked){
    updateLockedTouch(ev);
    ev.preventDefault();
    return;
  }
  if(!dragRot.active) return;
  const ang = clientAngle(ev);
  if(ang == null) return;
  const delta = ang - dragRot.startAngle;
  if(Math.abs(shortestDelta(dragRot.startAngle, ang)) > 0.01) dragRot.moved = true;
  const dir = (dragRot.anchor === 'disk') ? -1 : 1;
  diskAngle = dragRot.startDiskAngle + dir * delta;
  diskOmega = 0;
  ev.preventDefault();
}
function endDrag(ev){
  if(diskLocked){
    stopLockedTouch(ev);
    return;
  }
  if(!dragRot.active) return;
  const wasTap = !dragRot.moved && ev && ev.type === 'pointerup';
  dragRot.active = false;
  if(ev && ev.pointerId != null && cv.releasePointerCapture){
    try{ cv.releasePointerCapture(ev.pointerId); }catch{}
  }
  if(wasTap) handleCanvasTap(ev);
}
cv.addEventListener('pointerdown', beginDrag, {passive:false});
cv.addEventListener('pointermove', moveDrag, {passive:false});
cv.addEventListener('pointerup', endDrag, {passive:false});
cv.addEventListener('pointercancel', endDrag, {passive:false});
cv.addEventListener('pointerleave', endDrag, {passive:false});

/* ωmax（log10軸） */
function fmtOmega(v){
  if (v >= 10) return v.toFixed(0);
  if (v >= 1)  return v.toFixed(2);
  if (v >= 0.1) return v.toFixed(3);
  return v.toFixed(4);
}
let omegaMaxExp = parseFloat(omegaMaxSlider.value);
let omegaMax = Math.pow(10, omegaMaxExp);
function applyOmegaMaxFromSlider(){
  omegaMaxExp = parseFloat(omegaMaxSlider.value);
  omegaMax = Math.pow(10, omegaMaxExp);
  omegaMaxVal.textContent = `${fmtOmega(omegaMax)} rad/s`;
}
applyOmegaMaxFromSlider();
omegaMaxSlider.oninput = ()=>{
  applyOmegaMaxFromSlider();
  // UI操作に追従して設定を永続化
  saveSettings();
};

/* MIDI transpose */
function formatTransposeValue(v){
  const sign = v >= 0 ? '+' : '';
  const suffix = t('transposeSuffix');
  return `${sign}${v} ${suffix}`;
}
function updateTransposeDisplay(){
  transposeVal.textContent = formatTransposeValue(midiTranspose);
}
function formatTime(sec){
  const clamped = Math.max(0, Math.floor(Number.isFinite(sec) ? sec : 0));
  const m = Math.floor(clamped / 60);
  const s = clamped % 60;
  return `${m}:${String(s).padStart(2, '0')}`;
}
function updateSeekUI(pos = 0, total = null){
  const totalSec = (total != null) ? Math.max(0, total) : Math.max(0, midiData?.lengthSec || 0);
  const posSec = Math.max(0, Math.min(pos || 0, totalSec));
  const frac = totalSec ? Math.min(1, posSec / totalSec) : 0;
  seekSlider.value = (frac * 1000).toFixed(2);
  seekSlider.disabled = !totalSec;
  seekTime.textContent = `${formatTime(posSec)} / ${formatTime(totalSec)}`;
}
updateSeekUI();
function applyTransposeSetting({shouldSave = true, preservePlayback = false} = {}){
  const raw = parseInt(transposeSlider.value, 10);
  const clamped = Math.max(-6, Math.min(6, Number.isNaN(raw) ? 0 : raw));
  midiTranspose = clamped;
  if(String(clamped) !== transposeSlider.value) transposeSlider.value = String(clamped);
  updateTransposeDisplay();
  if(shouldSave) saveSettings();
  rebuildMidiView({preservePlayback});
}
updateTransposeDisplay();
transposeSlider.addEventListener('input', ()=> applyTransposeSetting({preservePlayback:true}));

/* ダンピング（比例）。スライダー値 = p%/s */
let dampPerSec = 0.99; // 初期（99%/s）
function fmtPct(p){ return Math.round(p).toString(); }
function updateDampFromSlider(){
  const raw = parseFloat(dampSlider.value);
  const p = Number.isNaN(raw) ? 0 : Math.max(0, Math.min(99, raw));
  dampPerSec = p / 100;                                   // 0.00〜0.99
  dampVal.textContent = `${fmtPct(p)}%/s`;
}
updateDampFromSlider();
// スライダーを動かすたびに内部状態と保存処理を更新
dampSlider.oninput = ()=>{ updateDampFromSlider(); saveSettings(); };

let snapZeroAlpha = snapAlphaCheckbox.checked;
// α=0時に角速度を強制的にゼロにするかどうかを反映
snapAlphaCheckbox.onchange = ()=>{ snapZeroAlpha = snapAlphaCheckbox.checked; saveSettings(); };

/* UI opacity / mass */
// UI全体の透明度をスライダーから算出し、最低値を0.1までに制限
function applyUIOpacity(){ const a=Math.max(0.1, Math.min(1, parseInt(uiopSlider.value,10)/100)); uiPanel.style.opacity=a; uiopVal.textContent=`${Math.round(a*100)}%`; }
applyUIOpacity(); uiopSlider.oninput = ()=>{ applyUIOpacity(); saveSettings(); };
// 対数スライダーで受け取った値を指数化してディスク質量へ変換
function updateMass(){ const lg=parseFloat(massSlider.value); diskMass=Math.pow(10,lg); massVal.textContent=`M=${diskMass.toFixed(2)}`; }
updateMass(); massSlider.oninput = ()=>{ updateMass(); saveSettings(); };

const CUT_MAX = 6;
let lowCutOct = Math.max(0, Math.min(CUT_MAX, parseInt(lowCutSlider.value,10) || 0));
let highCutOct = Math.max(0, Math.min(CUT_MAX, parseInt(highCutSlider.value,10) || 0));
function activeOctaveCount(){ return Math.max(1, OCTAVES - lowCutOct - highCutOct); }
function minDisplayFreq(){ return F_LOW * Math.pow(2, lowCutOct); }
function maxDisplayFreq(){ return F_LOW * Math.pow(2, lowCutOct + activeOctaveCount()); }
function formatCutValue(v){ return formatCutValueForLang(v, lang); }
function updateCutDisplays(){
  lowCutVal.textContent = formatCutValue(lowCutOct);
  highCutVal.textContent = formatCutValue(highCutOct);
}
function clampLowCut(value){
  const maxAllowed = Math.min(CUT_MAX, Math.max(0, OCTAVES - 1 - highCutOct));
  return Math.max(0, Math.min(maxAllowed, value));
}
function clampHighCut(value){
  const maxAllowed = Math.min(CUT_MAX, Math.max(0, OCTAVES - 1 - lowCutOct));
  return Math.max(0, Math.min(maxAllowed, value));
}
function applyLowCut(value, shouldSave = true){
  const clamped = clampLowCut(Number.isNaN(value) ? 0 : value);
  // スライダー表示と内部状態をクランプ後の値に揃える
  if(String(clamped) !== lowCutSlider.value) lowCutSlider.value = String(clamped);
  if(lowCutOct !== clamped){
    lowCutOct = clamped;
    if(shouldSave) saveSettings();
  }else if(shouldSave){
    saveSettings();
  }
  updateCutDisplays();
}
function applyHighCut(value, shouldSave = true){
  const clamped = clampHighCut(Number.isNaN(value) ? 0 : value);
  // 無駄な保存処理を避けるため、変化があったときだけ保存
  if(String(clamped) !== highCutSlider.value) highCutSlider.value = String(clamped);
  if(highCutOct !== clamped){
    highCutOct = clamped;
    if(shouldSave) saveSettings();
  }else if(shouldSave){
    saveSettings();
  }
  updateCutDisplays();
}
updateCutDisplays();
lowCutSlider.addEventListener('input', ()=>{
  const value = parseInt(lowCutSlider.value,10);
  applyLowCut(Number.isNaN(value) ? 0 : value);
});
highCutSlider.addEventListener('input', ()=>{
  const value = parseInt(highCutSlider.value,10);
  applyHighCut(Number.isNaN(value) ? 0 : value);
});

DEFAULT_SETTINGS = collectSettingsFromUI();
if(resetBtn){
  resetBtn.addEventListener('click', ()=>{
    // ページ初期化直後の設定スナップショットを基準値として利用
    const defaults = DEFAULT_SETTINGS || collectSettingsFromUI();
    const currentLang = lang;
    // 言語選択だけは保持したまま他のパラメータをリセット
    applySettings(defaults, {force:true});
    lang = currentLang;
    midiTranspose = 0;
    transposeSlider.value = '0';
    applyTransposeSetting({preservePlayback:false});
    finalizeAppliedSettings({shouldConnectMIDI:true});
    saveSettings();
  });
}

/* ===== Note state ===== */
// liveNotes と fileNotes は後段の描画・物理計算で参照する入力ノート集合を保持する。
// どちらも MIDI ノート番号をキー、ベロシティを値とした Map とし、
// 実行時に随時追加・削除される動的な状態を扱う。
const liveNotes = new Map();     // ハードMIDI入力の現在押下
const fileNotes = new Map();     // 再生中のMIDIファイル由来
const tapNotes = new Map();      // キャンバスタップによる一時的な入力
const lockedTouchNotes = new Map(); // ロック中のタッチ入力（押下中のみ保持）
const tapNoteTimeouts = new Map();
const lockedTouches = new Map(); // pointerId -> {midi, vel}
const mapToPoints = (m)=> Array.from(m, ([midi, vel])=>({midi, vel}));
const TAP_NOTE_DURATION_SEC = 0.8;
const trainerInputState = ()=> mergeNoteMaps(liveNotes, tapNotes, lockedTouchNotes);
function trainerOnInputChange(){
  if(fileOp.value==='train' && trainer && trainer.active && trainer.kind==='gate'){
    trainer.considerAdvance(trainerInputState());
    updateTrainerUI();
  }
}
function handleRealtimeTrainerInput(note, isOn, vel){
  if(fileOp.value!=='train' || !trainer || !trainer.active || trainer.kind!=='realtime') return;
  const ctx = ensureCtx();
  const abs = (ctx && ctx.state==='running') ? ctx.currentTime : performance.now()/1000;
  trainer.processInput(note, isOn ? 'on' : 'off', vel, abs);
  trainer.advance(trainer.now());
  updateTrainerUI();
}
function buildTrainerForMode(){
  if(!midiData){
    if(midiDataRaw){
      midiData = applyTransposeToMIDI(midiDataRaw, midiTranspose);
    }else{
      return null;
    }
  }
  const noteCount = Array.isArray(midiData.notes) ? midiData.notes.length : 0;
  if(noteCount <= 0){
    trainerStat.textContent = 'ring: no notes in MIDI';
    return null;
  }
  if(trainerMode === 'realtime'){
    return new RealTimeTrainer(midiData, {
      toleranceMs: timingToleranceMs,
      holdRatio: holdTolerancePct/100,
      lookaheadSec: ringLookaheadSec
    });
  }
  return new GateTrainer(midiData);
}

function closestNoteForTap(theta, radius){
  const {rMax, step, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq} = ringParams();
  if(!Number.isFinite(rMax) || rMax <= 0) return null;

  let bestPc = 0;
  let bestAngleDiff = Infinity;
  for(let pc=0; pc<12; pc++){
    const idx = FIFTH_INDEX[pc];
    const ang = baseAngleFromFifthIndex(idx) + worldRot;
    const diff = Math.abs(shortestDelta(ang, theta));
    if(diff < bestAngleDiff){
      bestAngleDiff = diff;
      bestPc = pc;
    }
  }

  let best = null;
  for(let midi=0; midi<=127; midi++){
    if(((midi%12)+12)%12 !== bestPc) continue;
    const freq = midiToHz(midi);
    if(freq < displayMinFreq || freq > displayMaxFreq) continue;
    const r = radiusFromFreq(freq, rMax, step, minRadius);
    const diff = Math.abs(r - radius);
    if(!best || diff < best.diff){
      best = {midi, diff};
    }
  }
  return best;
}

function playTapNote(midi, velocity = 0.9){
  const ctx = ensureCtx();
  if(!tapSynth) tapSynth = new PolySynth(ctx);
  applySeekMuteState();
  const vel = Math.max(0, Math.min(1, velocity));
  const now = ctx.currentTime;
  tapSynth.noteOn(midi, vel, now);
  tapSynth.noteOff(midi, now + TAP_NOTE_DURATION_SEC);
  tapNotes.set(midi, vel);

  const prev = tapNoteTimeouts.get(midi);
  if(prev) clearTimeout(prev);
  const to = setTimeout(()=>{
    tapNotes.delete(midi);
    tapNoteTimeouts.delete(midi);
    trainerOnInputChange();
  }, TAP_NOTE_DURATION_SEC * 1000 + 10);
  tapNoteTimeouts.set(midi, to);
  trainerOnInputChange();
}

function handleCanvasTap(ev){
  if(diskLocked) return;
  const polar = clientPolar(ev);
  if(!polar) return;
  const {rMax} = ringParams();
  if(!Number.isFinite(rMax) || polar.r > rMax + 32) return;
  const nearest = closestNoteForTap(polar.theta, polar.r);
  if(!nearest) return;
  playTapNote(nearest.midi);
}

function lockedMidiActiveElsewhere(midi, excludeId = null){
  for(const [pid, info] of lockedTouches){
    if(pid === excludeId) continue;
    if(info && info.midi === midi) return true;
  }
  return false;
}
function refreshLockedTouchNotes(){
  lockedTouchNotes.clear();
  for(const info of lockedTouches.values()){
    if(!info || info.midi == null) continue;
    const prev = lockedTouchNotes.get(info.midi);
    if(prev == null || info.vel > prev) lockedTouchNotes.set(info.midi, info.vel);
  }
}
function startLockedTouch(ev){
  const pid = (ev && ev.pointerId != null) ? ev.pointerId : 'mouse';
  const polar = clientPolar(ev);
  if(!polar) return;
  const {rMax} = ringParams();
  if(!Number.isFinite(rMax) || polar.r > rMax + 32) return;
  const nearest = closestNoteForTap(polar.theta, polar.r);
  if(!nearest) return;
  const ctx = ensureCtx();
  if(!tapSynth) tapSynth = new PolySynth(ctx);
  applySeekMuteState();
  const vel = 0.9;
  if(!lockedMidiActiveElsewhere(nearest.midi)){
    tapSynth.noteOn(nearest.midi, vel, ctx.currentTime);
  }
  lockedTouches.set(pid, {midi: nearest.midi, vel});
  refreshLockedTouchNotes();
  trainerOnInputChange();
  if(ev && ev.pointerId != null && cv.setPointerCapture){
    try{ cv.setPointerCapture(ev.pointerId); }catch{}
  }
  ev.preventDefault();
}
function stopLockedTouch(ev){
  const pid = (ev && ev.pointerId != null) ? ev.pointerId : 'mouse';
  const info = lockedTouches.get(pid);
  if(!info) return;
  lockedTouches.delete(pid);
  if(tapSynth && !lockedMidiActiveElsewhere(info.midi)){
    tapSynth.noteOff(info.midi);
  }
  refreshLockedTouchNotes();
  trainerOnInputChange();
  if(ev && ev.pointerId != null && cv.releasePointerCapture){
    try{ cv.releasePointerCapture(ev.pointerId); }catch{}
  }
}
function stopAllLockedTouches(){
  if(tapSynth){
    for(const info of lockedTouches.values()){
      if(info && info.midi != null) tapSynth.noteOff(info.midi);
    }
  }
  if(cv && cv.releasePointerCapture){
    for(const pid of lockedTouches.keys()){
      if(typeof pid === 'number'){
        try{ cv.releasePointerCapture(pid); }catch{}
      }
    }
  }
  lockedTouches.clear();
  refreshLockedTouchNotes();
  trainerOnInputChange();
}
function updateLockedTouch(ev){
  const pid = (ev && ev.pointerId != null) ? ev.pointerId : 'mouse';
  const existing = lockedTouches.get(pid);
  if(!existing) return;
  const polar = clientPolar(ev);
  const {rMax} = ringParams();
  if(!polar || !Number.isFinite(rMax) || polar.r > rMax + 32){
    if(existing) stopLockedTouch(ev);
    return;
  }
  const nearest = closestNoteForTap(polar.theta, polar.r);
  if(!nearest){
    if(existing) stopLockedTouch(ev);
    return;
  }
  if(existing && existing.midi === nearest.midi) return;
  const ctx = ensureCtx();
  if(!tapSynth) tapSynth = new PolySynth(ctx);
  applySeekMuteState();
  if(existing && !lockedMidiActiveElsewhere(existing.midi, pid)){
    tapSynth.noteOff(existing.midi);
  }
  const vel = existing ? existing.vel : 0.9;
  if(!lockedMidiActiveElsewhere(nearest.midi, pid)){
    tapSynth.noteOn(nearest.midi, vel, ctx.currentTime);
  }
  lockedTouches.set(pid, {midi: nearest.midi, vel});
  refreshLockedTouchNotes();
  trainerOnInputChange();
}

// NOTE_GUIDE_MARKS は水面に描画する目盛りラベルの一覧。
// degree 方向と表示文字列を組み合わせて定義し、
// drawNoteGuides 内で極座標位置決定に用いる。
const NOTE_GUIDE_MARKS = [
  {deg: 30, label: '+1'},
  {deg: 60, label: '+2'},
  {deg: 90, label: '+3'},
  {deg: 120, label: '+4'},
  {deg: 150, label: '+5'},
  {deg: 180, label: 'T'},
  {deg: -30, label: '-1'},
  {deg: -60, label: '-2'},
  {deg: -90, label: '-3'},
  {deg: -120, label: '-4'},
  {deg: -150, label: '-5'}
];

// NOTE_GUIDE_BASE_COLORS は 1 周分のグラデーション定義。
// offset を 0.0-1.0 の範囲で解釈し、各区間を線形補間することで
// 現在角度に応じた色を生成する。
const NOTE_GUIDE_BASE_COLORS = [
  {offset: 0.00, rgba: [255, 255, 255, 0]},  // south -> transparent
  {offset: 0.25, rgba: [224, 64, 48, 1]},    // west -> red
  {offset: 0.50, rgba: [0, 0, 0, 1]},        // north -> black
  {offset: 0.75, rgba: [64, 200, 120, 1]},   // east -> green
  {offset: 1.00, rgba: [255, 255, 255, 0]}   // wrap back to south
];

// 与えられた offset（周回位置）から NOTE_GUIDE_BASE_COLORS を補間し、
// 実際に使用する RGBA 値を算出する。
function interpolateNoteGuideColor(offset){
  const normalized = ((offset % 1) + 1) % 1;
  const stops = NOTE_GUIDE_BASE_COLORS;
  if(normalized === 0){
    const [r,g,b,a] = stops[0].rgba;
    return {r, g, b, a};
  }
  for(let i=0; i<stops.length-1; i++){
    const current = stops[i];
    const next = stops[i+1];
    if(normalized >= current.offset && normalized <= next.offset){
      const span = next.offset - current.offset;
      const t = span === 0 ? 0 : (normalized - current.offset) / span;
      const r = Math.round(current.rgba[0] + (next.rgba[0] - current.rgba[0]) * t);
      const g = Math.round(current.rgba[1] + (next.rgba[1] - current.rgba[1]) * t);
      const b = Math.round(current.rgba[2] + (next.rgba[2] - current.rgba[2]) * t);
      const a = current.rgba[3] + (next.rgba[3] - current.rgba[3]) * t;
      return {r, g, b, a};
    }
  }
  const [r,g,b,a] = stops[stops.length-1].rgba;
  return {r, g, b, a};
}

// RGBA オブジェクトを CSS 互換の rgba() 文字列へ変換する小さなユーティリティ。
function rgbaToCss({r,g,b,a}){
  const alpha = Math.max(0, Math.min(1, a));
  const rounded = Math.round(alpha * 1000) / 1000;
  return `rgba(${r},${g},${b},${rounded})`;
}

// NOTE_GUIDE_BASE_COLORS と interpolateNoteGuideColor を組み合わせて
// 指定 offset に対応する CSS 色文字列を得るヘルパー。
function noteGuideColorForOffset(offset){
  return rgbaToCss(interpolateNoteGuideColor(offset));
}

const NOTE_GUIDE_SEGMENT_COUNT = 12;
const NOTE_GUIDE_SEGMENT_SPAN = 1 / NOTE_GUIDE_SEGMENT_COUNT;
const NOTE_GUIDE_SEGMENT_HALF_SPAN = NOTE_GUIDE_SEGMENT_SPAN / 2;
// NOTE_GUIDE_SEGMENTS はグラデーションをセグメント単位に事前分割した配列。
// 描画ループで毎回補間するコストを抑えるため、中心 offset ごとに色を保持する。
const NOTE_GUIDE_SEGMENTS = Array.from({length: NOTE_GUIDE_SEGMENT_COUNT}, (_, i)=>{
  const centerOffset = i / NOTE_GUIDE_SEGMENT_COUNT;
  const startOffset = centerOffset - NOTE_GUIDE_SEGMENT_HALF_SPAN;
  const endOffset = centerOffset + NOTE_GUIDE_SEGMENT_HALF_SPAN;
  let rgba = interpolateNoteGuideColor(centerOffset);
  if(i === 0){
    rgba = {r: 255, g: 255, b: 255, a: 0};
  }
  return {startOffset, endOffset, rgba, css: rgbaToCss(rgba)};
});

// drawNoteGuides は音の位置に応じて水面の扇形やラベルを描画する。
// notePositions: 描画対象となる polar 座標情報を含む配列。
// cx/cy: キャンバス中心、diskRadius: 最大半径。
  function drawNoteGuides(notePositions, cx, cy, diskRadius){
    // ガイドを描く必要が無い状況 (データが無い、透明度 0) は即座に打ち切る。
    if(!notePositions.length || (noteGuideAlpha <= 0 && noteGuideLabelAlpha <= 0)) return;
    const fontPx = Math.round(12 * devicePixelRatio);

    if(noteGuideAlpha > 0){
      ctx.save();
      ctx.globalAlpha = noteGuideAlpha;
      const fullTurn = Math.PI * 2;
      // rAbs が有効なノートだけを取り出し、遠い順に並べて半径の大小関係を把握する。
      const sortedByRadius = [...notePositions]
        .filter(pos=>Number.isFinite(pos.rAbs) && pos.rAbs > 0)
        .sort((a,b)=> b.rAbs - a.rAbs);
      const innerRadiusByMidi = new Map();
      // 各ノートについて、次に近いノートの半径を「内側の境界」として記録する。
      // 次のノートが存在しない場合はディスクを 12 分割した幅だけ内側へ縮める。
      for(let i=0; i<sortedByRadius.length; i++){
        const current = sortedByRadius[i];
        const next = sortedByRadius[i+1];
        let inner = next ? next.rAbs : current.rAbs - (diskRadius / 12);
        if(!Number.isFinite(inner)) inner = 0;
        innerRadiusByMidi.set(current.midi, Math.max(0, inner));
      }

      // ノートごとに外周半径と求めた内周半径でドーナツ状の扇形を描画する。
      for(const pos of notePositions){
        const outerRadius = pos.rAbs;
        if(!Number.isFinite(outerRadius) || outerRadius <= 0) continue;
        const rawInner = innerRadiusByMidi.get(pos.midi);
        const innerRadius = rawInner==null ? 0 : Math.max(0, Math.min(outerRadius, rawInner));
        if(innerRadius >= outerRadius && innerRadius !== 0) continue;

        // NOTE_GUIDE_SEGMENTS で事前計算した色グラデーションを扇形ごとに適用する。
        for(let i=0; i<NOTE_GUIDE_SEGMENT_COUNT; i++){
          const segment = NOTE_GUIDE_SEGMENTS[i];
          const {rgba, css, startOffset, endOffset} = segment;
          if(rgba.a <= 0) continue;
          const startAngle = -pos.theta + endOffset * fullTurn;
          const endAngle = -pos.theta + startOffset * fullTurn;

          // 外周から内周に向かってパスを閉じ、水面に重ねる扇状の塗りを行う。
          ctx.beginPath();
          ctx.arc(cx, cy, outerRadius, startAngle, endAngle, true);
          if(innerRadius > 0){
            ctx.arc(cx, cy, innerRadius, endAngle, startAngle, false);
          }else{
            ctx.lineTo(cx, cy);
          }
          ctx.closePath();
          ctx.fillStyle = css;
          ctx.fill();
        }
      }

      ctx.restore();
    }

    if(noteGuideLabelAlpha > 0){
      ctx.save();
      ctx.globalAlpha = noteGuideLabelAlpha;
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${fontPx}px system-ui`;

      // それぞれのノートの極座標をデカルト座標に変換し、ラベル文字列を配置する。
      for(const pos of notePositions){
        const radius = pos.rAbs;
        if(!Number.isFinite(radius) || radius <= 0) continue;

        // NOTE_GUIDE_MARKS に定義されたマーク (度数や文字) を回転角度分だけ配置。
        for(const mark of NOTE_GUIDE_MARKS){
          const angle = pos.theta + mark.deg * Math.PI / 180;
          const {x, y} = polarToXY(cx, cy, radius, angle);
          ctx.fillText(mark.label, x, y);
        }
      }

      ctx.restore();
    }
  }

/* ===== Drawing ===== */
function drawNotes(points, drawRot){
  if(!points.length) return;
  const {rMax, step, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq}=ringParams(); const cx=cv.width/2, cy=cv.height/2;

  const inRange = [];
  const belowRange = [];
  const aboveRange = [];
  // 画面内に入る音・低すぎる音・高すぎる音を分類してエッジケースの描画を安定させる
  for(const p of points){
    const f = midiToHz(p.midi);
    if(f < displayMinFreq){
      belowRange.push({midi:p.midi, vel:p.vel, f});
    }else if(f > displayMaxFreq){
      aboveRange.push({midi:p.midi, vel:p.vel, f});
    }else{
      inRange.push({midi:p.midi, vel:p.vel, f});
    }
  }
  if(!inRange.length && !belowRange.length && !aboveRange.length) return;

  let low=null, high=null;
  const allPoints = [...inRange, ...belowRange, ...aboveRange];
  for(const p of allPoints){
    if(!low || p.f<low.f) low=p;
    if(!high|| p.f>high.f) high=p;
  }
  function ring(p, color, label, position = 'top'){
    // MIDIノートを極座標に変換して円形のマーカーとラベルを描く
    const freq = (p && p.f!=null) ? p.f : midiToHz(p.midi);
    const th=angleForMidiDraw(p.midi, drawRot), r=radiusFromFreq(freq,rMax,step,minRadius), {x,y}=polarToXY(cx,cy,r,th);
    ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=3; ctx.arc(x,y,16+10*p.vel*devicePixelRatio,0,2*Math.PI); ctx.stroke();
    ctx.fillStyle=color; ctx.font=`${11*devicePixelRatio}px system-ui`; ctx.textAlign='center';
    const labelOffset = 22 * devicePixelRatio;
    if(position === 'bottom'){
      ctx.textBaseline='top';
      ctx.fillText(label, x, y + labelOffset);
    }else{
      ctx.textBaseline='bottom';
      ctx.fillText(label, x, y - labelOffset);
    }
  }
function labelOnly(p, label, position = 'top', color = 'rgba(220,220,220,0.9)'){
  const freq = (p && p.f!=null) ? p.f : midiToHz(p.midi);
  const th=angleForMidiDraw(p.midi, drawRot), r=radiusFromFreq(freq,rMax,step,minRadius), {x,y}=polarToXY(cx,cy,r,th);
  ctx.fillStyle=color; ctx.font=`${11*devicePixelRatio}px system-ui`; ctx.textAlign='center';
  const labelOffset = 18 * devicePixelRatio;
    if(position === 'bottom'){
      ctx.textBaseline='top';
      ctx.fillText(label, x, y + labelOffset);
    }else{
      ctx.textBaseline='bottom';
    ctx.fillText(label, x, y - labelOffset);
  }
}

function noteNameFromMidi(midi){
  const pc = ((midi%12)+12)%12;
  return LABEL_ENH[pc] || String(pc);
}

function drawRealtimeRing(trainer, drawRot, segments = null, nowSec = null){
  if(!trainer || !trainer.active) return;
  const {rMax} = ringParams();
  const cx = cv.width/2, cy = cv.height/2;
  const outer = (rMax + 34);
  const inner = (rMax + 12);
  const midR = (outer + inner) / 2;
  const baseAng = -Math.PI/2;
  const nowSecVal = nowSec == null ? trainer.now() : nowSec;
  const wasActive = trainer.active;
  trainer.advance(nowSecVal);
  if(wasActive && !trainer.active) updateTrainerUI();
  const lookahead = trainer.lookaheadSec || ringLookaheadSec;
  const segmentsToUse = segments || trainer.segments(nowSecVal, lookahead);
  const firstNote = trainer.firstNoteSec;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(drawRot);
  ctx.lineCap = 'round';
  ctx.globalAlpha = ringAlpha;

  ctx.lineWidth = Math.max(2, (outer-inner)*0.35);
  ctx.strokeStyle = `rgba(255,255,255,${0.3*ringAlpha})`;
  ctx.beginPath();
  ctx.arc(0,0, midR, 0, 2*Math.PI);
  ctx.stroke();

  ctx.lineWidth = Math.max(2, (outer-inner)*0.4);
  ctx.strokeStyle = `rgba(255,255,255,${0.9*ringAlpha})`;
  ctx.beginPath();
  ctx.moveTo(inner*Math.cos(baseAng), inner*Math.sin(baseAng));
  ctx.lineTo(outer*Math.cos(baseAng), outer*Math.sin(baseAng));
  ctx.stroke();

  ctx.lineWidth = Math.max(6*devicePixelRatio, outer-inner);

  if(!segmentsToUse.length && Number.isFinite(firstNote) && firstNote > nowSecVal){
    ctx.save();
    ctx.fillStyle = `rgba(255,255,255,${ringAlpha})`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${12*devicePixelRatio}px system-ui`;
    const msg = `waiting… first note in ${(firstNote - nowSecVal).toFixed(2)}s`;
    ctx.fillText(msg, 0, -outer - 14*devicePixelRatio);
    ctx.restore();
  }

  for(const seg of segmentsToUse){
    const startDelta = seg.startSec - nowSecVal;
    const endDelta = seg.endSec - nowSecVal;
    if(endDelta < -trainer.toleranceSec) continue;
    const startFrac = startDelta / lookahead;
    const endFrac = Math.min(1, Math.max(startFrac + 0.01, endDelta / lookahead));
    const startAng = baseAng + startFrac * 2*Math.PI;
    const endAng = baseAng + endFrac * 2*Math.PI;
    const pc = ((seg.note%12)+12)%12;
    const [r,g,b] = NOTE_BG[pc] || [200,200,200];
    const onColor = `rgba(${r},${g},${b},${ringAlpha})`;
    const activeColor = seg.state==='on' ? `rgba(${r},${g},${b},${Math.min(1, ringAlpha+0.15)})` : onColor;
    ctx.strokeStyle = activeColor;
    ctx.beginPath();
    ctx.arc(0,0, midR, startAng, endAng, false);
    ctx.stroke();

    // ラベル
    const midAng = (startAng + endAng) / 2;
    const labelPos = polarToXY(0, 0, outer + 10*devicePixelRatio, midAng);
    ctx.save();
    ctx.fillStyle = `rgba(255,255,255,${ringAlpha})`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${11*devicePixelRatio}px system-ui`;
    const label = `${noteNameFromMidi(seg.note)} ${Math.max(0.05, seg.len).toFixed(1)}s`;
    ctx.fillText(label, labelPos.x, labelPos.y);
    ctx.restore();
  }

  ctx.restore();
}
  if(low)  ring(low,'rgba(0,200,255,0.95)','LOW','bottom');
  if(high) ring(high,'rgba(255,160,0,0.95)','HIGH','top');

  if(inRange.length){
    const strongestByMidi = new Map();
    for(const p of inRange){
      const current = strongestByMidi.get(p.midi);
      if(!current || p.vel > current.vel){
        strongestByMidi.set(p.midi, p);
      }
    }
    const ranked = Array.from(strongestByMidi.values())
      .sort((a,b)=> a.f - b.f);
    for(let i=0;i<ranked.length;i++){
      const p = ranked[i];
      if((low && p.midi === low.midi) || (high && p.midi === high.midi)) continue;
      labelOnly(p, String(i+1), 'top');
    }
  }

  const toPosition = (p)=>{
    const theta = angleForMidiDraw(p.midi, drawRot);
    const rAbs = radiusFromFreq(p.f, rMax, step, minRadius);
    const {x, y} = polarToXY(cx, cy, rAbs, theta);
    return {...p, theta, rAbs, x, y};
  };

  const notePositions = inRange.map(toPosition);
  if(notePositions.length) drawNoteGuides(notePositions, cx, cy, rMax);
  const straightLinePositions = allPoints.map(toPosition);

  if(straightLinePositions.length>=2 && straightLinkAlpha>0){
    ctx.save();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = `rgba(255,128,0,${straightLinkAlpha})`;
    for(let i=0;i<straightLinePositions.length-1;i++){
      const a = straightLinePositions[i];
      for(let j=i+1;j<straightLinePositions.length;j++){
        const b = straightLinePositions[j];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  for(const p of notePositions){
    const radius=4+12*p.vel, alpha=0.3+0.6*p.vel;
    ctx.beginPath(); ctx.fillStyle=`rgba(255,255,255,${alpha})`; ctx.arc(p.x,p.y,radius,0,2*Math.PI); ctx.fill();
  }

  if(inRange.length>=2){
    const xs = inRange.map(p=>({m:p.midi,f:p.f})).sort((a,b)=>a.f-b.f);
    ctx.lineWidth=2; ctx.strokeStyle=`rgba(255,255,255,${linkAlpha})`;
    for(let i=0;i<xs.length-1;i++){
      const m0=xs[i].m,f0=xs[i].f,m1=xs[i+1].m,f1=xs[i+1].f;
      const r0=radiusFromFreq(f0,rMax,step,minRadius), th0=angleForMidiDraw(m0, drawRot);
      const r1=radiusFromFreq(f1,rMax,step,minRadius), th1=angleForMidiDraw(m1, drawRot);
      const dth = shortestDelta(th0, th1);
      const steps=48; ctx.beginPath();
      for(let s=0;s<=steps;s++){ const t=s/steps, r=r0+t*(r1-r0), th=th0+t*dth; const {x,y}=polarToXY(cx,cy,r,th); if(s===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.stroke();
    }
  }

  if(belowRange.length || aboveRange.length){
    const highMarkerRadius = Math.max(minRadius, rMax * 0.1);
    const drawOutOfRange = (list, radius, color)=>{
      for(const p of list){
        const theta = angleForMidiDraw(p.midi, drawRot);
        const {x,y}=polarToXY(cx,cy,radius,theta);
        const markerRadius=4+12*p.vel;
        ctx.beginPath(); ctx.fillStyle=color; ctx.arc(x,y,markerRadius,0,2*Math.PI); ctx.fill();
      }
    };
    if(belowRange.length){
      drawOutOfRange(belowRange, rMax, 'rgba(255,120,120,0.85)');
    }
    if(aboveRange.length){
      drawOutOfRange(aboveRange, highMarkerRadius, 'rgba(120,180,255,0.85)');
    }
  }
}

/* ターゲット描画（トレーナー） */
// drawTargetNotes はトレーナーモードで指定したターゲットノートを視覚化する。
// MIDI 番号を受け取り、表示範囲内でリング上にハイライトを描画する。
function drawTargetNotes(targets, drawRot){
  if(!targets || !targets.length) return;
  const {rMax, step, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq}=ringParams(); const cx=cv.width/2, cy=cv.height/2;
  for(const midi of targets){
    const freq = midiToHz(midi);
    if(freq < displayMinFreq || freq > displayMaxFreq) continue;
    const th=angleForMidiDraw(midi, drawRot), r=radiusFromFreq(freq,rMax,step,minRadius), {x,y}=polarToXY(cx,cy,r,th);
    ctx.beginPath(); ctx.strokeStyle='rgba(100,255,120,0.95)'; ctx.lineWidth=4; ctx.arc(x,y,15*devicePixelRatio,0,2*Math.PI); ctx.stroke();
    ctx.fillStyle='rgba(100,255,120,0.95)'; ctx.font=`${12*devicePixelRatio}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.fillText('TARGET', x, y+22*devicePixelRatio);
  }
}

function drawRealtimeTargetsOnDisk(segments, drawRot){
  if(!segments || !segments.length) return;
  const targets = Array.from(new Set(segments.map(s=>s.note)));
  drawTargetNotes(targets, drawRot);
}

/* 移動ド数字（水面回転と同期） */
// drawMovableDoNumbers は移動ド（メロディック・ソルフェージュ）の数字を描く。
// 回転角 halfCenter に追従しながらリング内側に等間隔で表示する。
function drawMovableDoNumbers(halfCenter, rMax, cx, cy){
  const r = rMax * 0.78;
  const fontPx = Math.round(Math.max(12, movNumSizePx) * devicePixelRatio);
  const pf=ctx.font, pa=ctx.globalAlpha, ps=ctx.fillStyle, pal=ctx.textAlign, pb=ctx.textBaseline;
  // 現在のフォント設定を保存しつつ移動ドの番号を書き込む
  ctx.font = `${fontPx}px system-ui`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.globalAlpha = movNumAlpha;
  ctx.fillStyle = 'rgba(255,220,70,1)';
  const seq = ['7','3','6','2','5','1','4','-7','-3','-6','-2','+4'];
  const start = halfCenter - Math.PI/2; // 水面右端
  for(let i=0;i<12;i++){
    const theta = start + i*(Math.PI/6);
    const x = cx + r*Math.cos(theta), y = cy + r*Math.sin(theta);
    ctx.fillText(seq[i], x, y);
  }
  ctx.font=pf; ctx.globalAlpha=pa; ctx.fillStyle=ps; ctx.textAlign=pal; ctx.textBaseline=pb;
}

/* ===== Main draw loop ===== */
let prevT=null;
// draw はキャンバス全体のメイン描画ループ。
// 物理演算の結果を反映しながら、水面・ノート・補助情報を毎フレーム再描画する。
function draw(){
  const w=cv.width, h=cv.height, cx=w/2, cy=h/2;
  const {rMax, step, octaves, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq} = ringParams();
  const now = performance.now()/1000;
  // 前フレームとの経過時間を計算し、極端な変動はクランプ
  const dt = prevT? Math.max(1/240, Math.min(0.25, now-prevT)) : 1/60;
  prevT = now;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#0d1016';
  ctx.fillRect(0,0,w,h);

  // ディスク本体（完全透過の背景）
  const diskRadius = rMax + 8;
  ctx.beginPath();
  ctx.arc(cx, cy, diskRadius, 0, 2*Math.PI);
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(220,235,255,0.18)';
  ctx.stroke();

  // 物理に使う入力
  // - 再生: ファイル由来 + ライブ入力
  // - トレーナ: ライブ入力のみ（ターゲットは描画だけ）
  const liveAndTap = mergeNoteMaps(liveNotes, tapNotes, lockedTouchNotes);
  const physicsPoints = (fileOp.value==='play')
    ? [...mapToPoints(liveAndTap),
       ...mapToPoints(fileNotes)]
    : [...mapToPoints(liveAndTap)];

  const hasPhysInput = physicsPoints.length>0;
  // 物理計算に使えるノートがあるかどうかを示すフラグ

  // 物理
  const tau = hasPhysInput ? torqueFromPoints(physicsPoints, GRAV_ABS, rMax, step, minRadius, displayMinFreq, displayMaxFreq, excludeMode) : 0;
  // トルクを質量で割って角加速度を求める
  const alpha = tau / Math.max(1e-6, diskMass);
  if (snapZeroAlpha && Math.abs(alpha) < 1e-6){
    diskOmega = 0;
  }else{
    diskOmega += alpha * dt;
  }

  // ダンピング：1秒あたり (1 - p%)^dt
  const k = Math.max(0, Math.min(1, 1 - dampPerSec));
  diskOmega *= Math.pow(k, dt);

  // 最大回転速度（対数スライダで設定）
  if(diskOmega > omegaMax) diskOmega = omegaMax;
  else if(diskOmega < -omegaMax) diskOmega = -omegaMax;

  diskAngle += diskOmega * dt;

  // 表示回転と水面中心
  const anchor = anchorSel.value;                 // 'water' | 'disk'
  const drawRot = (anchor==='water') ? diskAngle : 0;
  const halfCenter = (anchor==='water') ? GRAV_ABS : (GRAV_ABS + diskAngle);
  worldRot = drawRot;

  info.textContent = `disk | τ=${tau.toFixed(3)} α=${alpha.toFixed(3)} ω=${diskOmega.toFixed(3)} rad/s`;

  // 放射線
  ctx.save(); ctx.translate(cx,cy);
  // 完全5度圏に基づく放射線を一度に描き、A音だけを強調表示
  const highlightAIndex = FIFTH_INDEX[9];
  for(let k2=0;k2<12;k2++){
    const ang = baseAngleFromFifthIndex(k2) - drawRot;
    const isA = (k2 === highlightAIndex);
    ctx.beginPath();
    ctx.strokeStyle = isA ? 'rgba(0,140,140,0.95)' : 'rgba(255,255,255,0.18)';
    ctx.lineWidth = isA ? 3 : 1.5;
    ctx.moveTo(0,0); ctx.lineTo((rMax+6)*Math.cos(ang),(rMax+6)*Math.sin(ang));
    ctx.stroke();
  }
  ctx.restore();

  // 同心円
  ctx.strokeStyle='rgba(255,255,255,0.22)';
  ctx.lineWidth = 1.5;
  for(let i=0;i<=octaves;i++){
    const rRaw = rMax - i*step;
    const radius = Math.max(minRadius, Math.min(rMax, rRaw));
    if(radius <= 0) continue; // iOS Safari throws if radius is 0 or negative
    // 半径が負にならないように安全策を入れつつ同心円を描く
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, 2*Math.PI);
    ctx.stroke();
  }
  ctx.lineWidth = 1;

  if(440 >= displayMinFreq && 440 <= displayMaxFreq){
    // 標準ピッチA4=440Hzの位置を特別なリングで示す
    const r440 = radiusFromFreq(440, rMax, step);
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(00,100,100,0.9)';
    ctx.lineWidth = 3;
    ctx.arc(cx, cy, r440, 0, 2*Math.PI);
    ctx.stroke();
  }
  ctx.lineWidth = 1;

  // 外周ラベル
  const fontPx = labelFontPx * devicePixelRatio * 0.95;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font = `${fontPx}px system-ui`;
  for(let k2=0;k2<12;k2++){
    const ang = baseAngleFromFifthIndex(k2) + drawRot;
    const tx = cx + (rMax+18)*Math.cos(ang), ty = cy - (rMax+18)*Math.sin(ang);
    const text = FIFTH_LABELS[k2];
    const pc = FIFTH_ORDER_PCS[k2]; const [r,g,b] = NOTE_BG[pc];
    const m = ctx.measureText(text);
    const padX = 6*devicePixelRatio, padY = 3*devicePixelRatio;
    const wbg = m.width + padX*2, hbg = fontPx + padY*2;
    const vx = tx - cx, vy = ty - cy;
    const safeX = (w/2) - (wbg/2 + 2*devicePixelRatio);
    const safeY = (h/2) - (hbg/2 + 2*devicePixelRatio);
    const sx = Math.min(1, Math.abs(vx)>0 ? safeX/Math.abs(vx) : 1);
    const sy = Math.min(1, Math.abs(vy)>0 ? safeY/Math.abs(vy) : 1);
    const s  = Math.min(sx, sy);
    const tx2 = cx + vx*s, ty2 = cy + vy*s;
    ctx.fillStyle = `rgba(${r},${g},${b},${labelBgAlpha})`;
    ctx.fillRect(tx2 - wbg/2, ty2 - hbg/2, wbg, hbg);
    if(labelTextAlpha>0){
      ctx.fillStyle=`rgba(255,255,255,${labelTextAlpha})`;
      ctx.fillText(text, tx2, ty2);
    }
  }

  // 水面半円＋移動ド数字
  ctx.save(); ctx.translate(cx,cy);
  ctx.beginPath(); ctx.moveTo(0,0);
  ctx.arc(0,0, rMax+6, halfCenter - Math.PI/2, halfCenter + Math.PI/2, false);
  ctx.closePath();
  ctx.fillStyle=`rgba(0,128,255,${waterAlpha})`; ctx.fill();
  ctx.beginPath();
  ctx.arc(0,0, rMax+6, halfCenter - Math.PI/2, halfCenter + Math.PI/2);
  ctx.strokeStyle=`rgba(0,128,255,${waterAlpha})`; ctx.lineWidth=2; ctx.stroke();
  ctx.restore();
  drawMovableDoNumbers(halfCenter, rMax, cx, cy);

  // 入力の可視化
  const livePts = mapToPoints(mergeNoteMaps(liveNotes, tapNotes, lockedTouchNotes));
  const filePts = mapToPoints(fileNotes);

  if(livePts.length) drawNotes(livePts, drawRot);
  if(filePts.length && fileOp.value==='play') drawNotes(filePts, drawRot);

  // ★トレーナーのターゲット表示（trainer.currentNotesを直接描画）
  if(fileOp.value==='train' && trainer && trainer.active){
    if(trainer.kind === 'gate'){
      const tn = trainer.currentNotes();
      if(tn && tn.length) drawTargetNotes(tn, drawRot);
    }else if(trainer.kind === 'realtime'){
      try{
        const nowSec = trainer.now();
        const segs = trainer.segments(nowSec, trainer.lookaheadSec || ringLookaheadSec) || [];
        drawRealtimeRing(trainer, drawRot, segs, nowSec);
        drawRealtimeTargetsOnDisk(segs, drawRot);
      }catch(err){
        console.error('realtime draw failed', err);
        trainerStat.textContent = 'ring: draw error';
      }
    }
  }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

/* ===== Audio ctx & synth ===== */
let audioCtx=null;
// 再利用できるAudioContextを返し、存在しない場合は新規作成
function ensureCtx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000}); return audioCtx; }
class PolySynth{
  constructor(ctx){
    this.ctx=ctx;
    this.masterGain=0.9;
    this.master=ctx.createGain();
    this.master.gain.value=this.masterGain;
    this.master.connect(ctx.destination);
    this.voices=new Map();
    this.muted=false;
  }
  // ノートオン時に2つのオシレータとローパスフィルタを構成し、ADSRでゲインを制御
  noteOn(midi, vel=1, when=null){
    const t = (when!=null)? when : this.ctx.currentTime;
    if(this.voices.has(midi)) this.noteOff(midi, t);
    const f=midiToHz(midi);
    const g=this.ctx.createGain(); g.gain.setValueAtTime(0,t);
    const o1=this.ctx.createOscillator(), o2=this.ctx.createOscillator();
    o1.type='sawtooth'; o2.type='square'; o1.frequency.setValueAtTime(f,t); o2.frequency.setValueAtTime(f,t); o2.detune.setValueAtTime(+3,t);
    const flt=this.ctx.createBiquadFilter(); flt.type='lowpass'; flt.frequency.setValueAtTime(3000,t); flt.Q.setValueAtTime(0.7,t);
    o1.connect(flt); o2.connect(flt); flt.connect(g); g.connect(this.master);
    const A=0.005,D=0.12,S=0.25+0.5*vel,R=0.32,peak=0.8*vel;
    g.gain.linearRampToValueAtTime(peak, t+A);
    g.gain.linearRampToValueAtTime(S*peak, t+A+D);
    o1.start(t); o2.start(t);
    this.voices.set(midi,{o1,o2,g,flt,R});
  }
  // ノートオフ時はターゲット減衰を設定し、一定時間後にノードを破棄
  noteOff(midi, when=null){
    const v=this.voices.get(midi); if(!v) return;
    const t=(when!=null)? when : this.ctx.currentTime, R=v.R;
    v.g.gain.setTargetAtTime(0,t,R/3);
    try { v.o1.stop(t+R+0.05); v.o2.stop(t+R+0.05); } catch(e){}
    setTimeout(()=>{ try{ v.g.disconnect(); v.flt.disconnect(); }catch{} }, (R+0.1)*1000);
    this.voices.delete(midi);
  }
  allNotesOff(){ for(const m of Array.from(this.voices.keys())) this.noteOff(m); }
  setMuted(m){
    this.muted = m;
    const target = m ? 0 : this.masterGain;
    this.master.gain.setTargetAtTime(target, this.ctx.currentTime, 0.01);
  }
}
let synth=null;
let tapSynth=null;

/* ===== Web MIDI In（常時） ===== */
let midiAccess=null;
const attachedInputs = new Set();

function hex(n){ return n.toString(16).padStart(2,'0'); }
function logMidi(ev){
  const d = Array.from(ev.data||[]).map(hex).join(' ');
  const name = ev.currentTarget && (ev.currentTarget.name||ev.currentTarget.id||'input');
  midiLast.textContent = `${t('last')} ${name}  ${d}`;
}
function midiMessageHandler(ev){
  logMidi(ev);
  const d=ev.data;
  if(!d || d.length<3) return;
  const st=d[0]&0xf0, note=d[1], vel=d[2];
  // ノートオン/ノートオフを解釈して可視化用のマップに反映
  if(st===0x90){
    if(vel>0){
      liveNotes.set(note, vel/127);
      if(liveMon.checked){ if(!synth) synth=new PolySynth(ensureCtx()); applySeekMuteState(); synth.noteOn(note, vel/127); }
      handleRealtimeTrainerInput(note, true, vel/127);
    }else{
      liveNotes.delete(note);
      if(synth) synth.noteOff(note);
      handleRealtimeTrainerInput(note, false, vel/127);
    }
  }else if(st===0x80){
    liveNotes.delete(note);
    if(synth) synth.noteOff(note);
    handleRealtimeTrainerInput(note, false, vel/127);
  }

  trainerOnInputChange();
}
async function setupMIDIInputs(){
  if(!isSecureContext && !window.__NATIVE_APP__){ updateMIDIStat(t('midiNeedSecure')); return; }
  if(!('requestMIDIAccess' in navigator)){ updateMIDIStat(t('midiUnsupported')); return; }
  try{
    // Web MIDI APIから利用可能なデバイス一覧を取得
    midiAccess = await navigator.requestMIDIAccess({sysex:false, software:true});
    midiAccess.onstatechange = refreshMIDIInputs;
    await refreshMIDIInputs();
    updateMIDIStat(`${t('midiReady')} (${midiAccess.inputs.size})`);
  }catch(e){
    updateMIDIStat(`${t('midiInitFailed')}: ${e.name||e.message}`);
  }
}
async function refreshMIDIInputs(){
  if(!midiAccess) return;
  midiDev.innerHTML='';
  const inputs = Array.from(midiAccess.inputs.values());
  // 利用可能なMIDI入力をプルダウンに並べる
  for(const inp of inputs){
    const opt=document.createElement('option'); opt.value=inp.id; opt.textContent=inp.name||inp.id; midiDev.appendChild(opt);
  }
  await connectMIDIAccordingToUI();
}
function detachAllInputs(){
  for(const inp of attachedInputs){
    try{ inp.onmidimessage=null; if(inp.removeEventListener) inp.removeEventListener('midimessage', midiMessageHandler); }catch{}
  }
  attachedInputs.clear();
}
async function attachInput(inp){
  try{ await inp.open(); }catch{}
  inp.onmidimessage = midiMessageHandler;
  if(inp.addEventListener) inp.addEventListener('midimessage', midiMessageHandler);
  attachedInputs.add(inp);
}
async function connectMIDIAccordingToUI(){
  if(!midiAccess) return;
  detachAllInputs();
  const inputs = Array.from(midiAccess.inputs.values());
  // 「全入力」がオンなら全ポートを購読し、そうでなければ選択されたデバイスに限定
  if(midiAll.checked || !midiDev.value){
    for(const inp of inputs) await attachInput(inp);
    updateMIDIStat(`${t('midiAllInputsStat')} (${inputs.length})`);
  }else{
    const target = midiAccess.inputs.get(midiDev.value);
    if(target){ await attachInput(target); updateMIDIStat(`${t('midiInputStatPrefix')} ${target.name||target.id}`); }
    else{ updateMIDIStat(t('midiNoDevice')); }
  }
}
midiDev.onchange = ()=>{ connectMIDIAccordingToUI(); saveSettings(); };
midiAll.onchange = ()=>{ connectMIDIAccordingToUI(); saveSettings(); };
// ライブモニタのON/OFFだけは状態を保存するだけで十分
liveMon.onchange = ()=>{ saveSettings(); };

/* ===== 自動開始 ===== */
function autoStart(){
  // AudioContextとMIDI初期化をアプリ起動時にまとめて実施
  ensureCtx();
  setupMIDIInputs().then(connectMIDIAccordingToUI);
}
document.addEventListener('DOMContentLoaded', ()=>{
  // ページ読み込み完了後にUIやMIDIの初期状態を整える
  loadSettings();
  updateUIVisibility();
  updateFileOpUI();
  autoStart();
  loadDefaultMIDI();
});

// iOS: ユーザー操作でAudioContextを復帰
['pointerdown','keydown','touchstart'].forEach(ev=>{
  // iOS Safariは自動再生を禁止するため、初回操作でresumeを試みる
  addEventListener(ev, ()=>{ try{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch{} }, {once:true});
});

/* ===== Disk torque ===== */
function torqueFromPoints(points, gravAbs, rMax, step, minRadius, minFreq, maxFreq, excludeMode){
  let tau = 0;
  for(const p of points){
    const thAbs = angleForMidiAbs(p.midi);  // ディスク絶対角
    const freq = midiToHz(p.midi);
    const r = radiusFromFreq(freq, rMax, step, minRadius);
    const rn = r / rMax;
    const d = shortestDelta(gravAbs, thAbs);
    const absd = Math.abs(d);

    // 除外側だけを±1°だけ広げる
    let excluded;
    if (excludeMode === 'filled'){
      excluded = absd <= (Math.PI/2 + EXCLUDE_PAD_RAD);
    }else{
      excluded = absd >= (Math.PI/2 - EXCLUDE_PAD_RAD);
    }
    if (excluded) continue;

    // ベロシティを0〜1に正規化し、半径と角度差からトルク寄与を計算
    const m = Math.max(0, Math.min(1, p.vel));
    tau += m * rn * Math.sin(d);
  }
  return tau;
}

/* ===== MIDI File loader / parser ===== */
// ファイル関連のメッセージを下部UIに表示
function uiLog(msg){ fileInfo.textContent = msg; }

async function fileToArrayBuffer(file){
  if (file && file.arrayBuffer) {
    // 新しいブラウザではFile#arrayBufferが直接使える
    try { return await file.arrayBuffer(); } catch(e) { /* fallback */ }
  }
  // 上記が失敗した場合はFileReaderで読み込むレガシールートを使用
  return await new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onload = ()=> resolve(fr.result);
    fr.onerror = ()=> reject(fr.error || new Error('FileReader error'));
    fr.readAsArrayBuffer(file);
  });
}
async function handlePickedFile(file){
  try{
    uiLog(`picked: ${file?.name || '(no name)'}  type:${file?.type || 'unknown'}  size:${file?.size || 0}B`);
    if(!file) throw new Error('no file');
    // ファイルをArrayBufferへ変換し、MIDIパーサに渡す準備をする
    const ab = await fileToArrayBuffer(file);
    if(!ab) throw new Error('arrayBuffer empty');

    const parsed = parseMIDI(ab);
    if(!parsed || !parsed.notes) throw new Error('parse failed');
    midiDataRaw = parsed;
    rebuildMidiView();

    const trks = (Array.isArray(midiData.tracks) ? midiData.tracks.length : (midiData.tracks ?? 0));
    uiLog(`OK: ${file.name}  trks:${trks}  ppq:${midiData.ppq}  len:${midiData.lengthSec.toFixed(2)}s  notes:${midiData.notes.length}`);
  }catch(err){
    uiLog(`解析失敗: ${err && err.message ? err.message : err}`);
    console.error(err);
  }
}

async function loadMIDIFromNative(base64, fileName = 'sample.mid'){
  try{
    const binary = atob(base64);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for(let i = 0; i < len; i++){ bytes[i] = binary.charCodeAt(i); }
    const blob = new Blob([bytes], { type: 'audio/midi' });
    let fileLike;
    try{
      fileLike = new File([blob], fileName, { type: blob.type || 'audio/midi', lastModified: Date.now() });
    }catch{
      fileLike = {
        name: fileName,
        type: blob.type || 'audio/midi',
        size: blob.size,
        arrayBuffer: () => blob.arrayBuffer()
      };
    }
    await handlePickedFile(fileLike);
  }catch(err){
    console.warn('failed to load MIDI from native:', err);
  }
}
window.__loadMIDIFromNative = loadMIDIFromNative;

function onFileInput(e){
  const f = e.target && e.target.files && e.target.files[0];
  if(f) handlePickedFile(f);
}
midiFileInput.addEventListener('change', onFileInput);
midiFileInput.addEventListener('input',  onFileInput);

async function loadDefaultMIDI(){
  if(midiData) return;
  if(window.__NATIVE_APP__){
    return;
  }
  try{
    uiLog('loading: sample.mid');
    const res = await fetch('sample.mid');
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const blob = await res.blob();
    const type = blob.type || 'audio/midi';
    const fileName = 'sample.mid';
    let fileLike;
    try{
      fileLike = new File([blob], fileName, { type, lastModified: Date.now() });
    }catch{
      fileLike = {
        name: fileName,
        type,
        size: blob.size,
        arrayBuffer: () => blob.arrayBuffer()
      };
    }
    await handlePickedFile(fileLike);
  }catch(err){
    console.warn('failed to load default MIDI file:', err);
  }
}

// D&D
addEventListener('dragover', e=>{ e.preventDefault(); });
addEventListener('drop', e=>{
  e.preventDefault();
  const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
  if(f && /\.mid(i)?$/i.test(f.name)) handlePickedFile(f);
});

/* ---- Simple Standard MIDI parser (format 0/1) ---- */
function parseMIDI(ab){
  const u8 = new Uint8Array(ab);
  let p = 0;
  function rdU32(){ const v=((u8[p]<<24)|(u8[p+1]<<16)|(u8[p+2]<<8)|u8[p+3])>>>0; p+=4; return v; }
  function rdU16(){ const v=((u8[p]<<8)|u8[p+1])>>>0; p+=2; return v; }
  function rdStr(n){ const s=String.fromCharCode.apply(null, u8.slice(p,p+n)); p+=n; return s; }
  function rdVLQ(){ let v=0; let b; do{ b=u8[p++]; v=(v<<7)|(b&0x7f); }while(b&0x80); return v; }

  function expect(tag){ const s=rdStr(4); if(s!==tag) throw new Error(`expect ${tag}, got ${s}`); }
  expect('MThd'); const len=rdU32(); const pHdr=p; const format=rdU16(); const ntrks=rdU16(); const division=rdU16(); p=pHdr+len;

  if(division & 0x8000) throw new Error('SMPTE time not supported');
  const ppq = division;

  const tracks=[];
  for(let t=0;t<ntrks;t++){
    expect('MTrk'); const tlen=rdU32(); const end=p+tlen; let tick=0; let running=0; const evs=[];
    let tempoEvents=[];
    while(p<end){
      const dt = rdVLQ(); tick += dt;
      let st = u8[p++];
      if(st<0x80){ p--; st = running; } else { running = st; }
      if(st===0xFF){
        const type=u8[p++]; const len=rdVLQ(); const data=u8.slice(p,p+len); p+=len;
        if(type===0x51 && len===3){ const usPerQ = (data[0]<<16)|(data[1]<<8)|data[2]; tempoEvents.push({tick, usPerQ}); }
      }else if(st===0xF0 || st===0xF7){
        const len=rdVLQ(); p+=len;
      }else{
        const hi=st&0xF0, ch=st&0x0F;
        function d(){ return u8[p++]; }
        if(hi===0xC0 || hi===0xD0){ d(); }
        else{
          const d1=d(), d2=d();
          if(hi===0x90){ const note=d1, vel=d2; evs.push({type:(vel>0)?'on':'off', tick, ch, note, vel}); }
          else if(hi===0x80){ evs.push({type:'off', tick, ch, note:d1, vel:d2}); }
        }
      }
    }
    tracks.push({events:evs, tempos:tempoEvents});
  }

  let tempos = tracks.flatMap(tr=>tr.tempos);
  tempos.sort((a,b)=>a.tick-b.tick);
  if(!tempos.length || tempos[0].tick!==0) tempos.unshift({tick:0, usPerQ:500000});

  const segments = [];
  let lastTick=0, curUsPerQ=tempos[0].usPerQ, accSec=0;
  segments.push({tick:0, usPerQ:curUsPerQ, timeSec:0});
  for(let i=1;i<tempos.length;i++){
    const T = tempos[i].tick;
    accSec += ((T-lastTick) * curUsPerQ) / 1e6 / ppq;
    segments.push({tick:T, usPerQ:tempos[i].usPerQ, timeSec:accSec});
    lastTick = T; curUsPerQ = tempos[i].usPerQ;
  }
  function ticksToSec(t){
    let lo=0, hi=segments.length-1, idx=0;
    while(lo<=hi){ const mid=(lo+hi)>>1; if(segments[mid].tick<=t){ idx=mid; lo=mid+1; } else hi=mid-1; }
    const s=segments[idx];
    return s.timeSec + ((t - s.tick) * s.usPerQ) / 1e6 / ppq;
  }

  const all = tracks.flatMap(tr=>tr.events);
  all.sort((a,b)=> (a.tick-b.tick) || (a.type==='off'?1:-1));
  const onStack = Array.from({length:16}, ()=>Array(128).fill(null));
  const notes = [];
  let lastTickAll = 0;
  for(const e of all){
    lastTickAll = Math.max(lastTickAll, e.tick);
    if(e.type==='on'){
      onStack[e.ch][e.note] = onStack[e.ch][e.note] || [];
      onStack[e.ch][e.note].push({tick:e.tick, vel:e.vel});
    }else if(e.type==='off'){
      const st = onStack[e.ch][e.note];
      if(st && st.length){
        const on = st.shift();
        notes.push({note:e.note, chan:e.ch, vel:Math.max(1,on.vel), startTick:on.tick, endTick:e.tick});
      }
    }
  }
  for(let ch=0; ch<16; ch++){
    for(let n=0;n<128;n++){
      const st = onStack[ch][n];
      if(st && st.length){
        for(const on of st){
          notes.push({note:n, chan:ch, vel:Math.max(1,on.vel), startTick:on.tick, endTick:lastTickAll});
        }
      }
    }
  }
  for(const n of notes){ n.startSec = ticksToSec(n.startTick); n.endSec = ticksToSec(n.endTick); }
  const lengthSec = notes.reduce((m,n)=>Math.max(m, n.endSec), 0);

  const onsets = new Map();
  for(const n of notes){ const arr = onsets.get(n.startTick) || []; arr.push({note:n.note, vel:n.vel}); onsets.set(n.startTick, arr); }
  const onsetTicks = Array.from(onsets.keys()).sort((a,b)=>a-b);

  return { ppq, tracks, tempos, segments, ticksToSec, notes, lengthSec, onsets, onsetTicks };
  }

  function applyTransposeToMIDI(data, shift){
    if(!data) return null;
    const clampNote = (n)=>{
      const v = n + shift;
      return (v < 0 || v > 127) ? null : v;
    };
    const notes = [];
    for(const n of data.notes || []){
      const nn = clampNote(n.note);
      if(nn==null) continue;
      notes.push({...n, note: nn});
    }
    const onsets = new Map();
    if(data.onsets){
      data.onsets.forEach((arr, tk)=>{
        const mapped = arr.map(o=>({note: clampNote(o.note), vel: o.vel})).filter(o=>o.note!=null);
        if(mapped.length) onsets.set(tk, mapped);
      });
    }
    const onsetTicks = Array.from(onsets.keys()).sort((a,b)=>a-b);
    return {...data, notes, onsets, onsetTicks, transpose: shift};
  }

  function rebuildMidiView({preservePlayback = false} = {}){
    if(!midiDataRaw) return;
    const resume = preservePlayback && player;
    const resumeCtx = resume ? player.ctx : null;
    const resumeRunning = resume ? player.running : false;
    const resumePos = resume ? player.currentPosition() : 0;
    if(player){
      player.stop();
      player = null;
    }
    midiData = applyTransposeToMIDI(midiDataRaw, midiTranspose);
    trainer = buildTrainerForMode();
    updateTrainerUI();
    updateSeekUI(resumePos, midiData.lengthSec);
    const ctx = resumeCtx || ensureCtx();
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
    player.setPosition(resumePos);
    if(resumeRunning) player.play();
  }

  /* ===== Player ===== */
  class Player{
  constructor(ctx, notes){
    this.ctx=ctx; this.notes=notes;
    this.events = [];
    for(const n of notes){
      this.events.push({time:n.startSec, type:'on', note:n.note, vel:n.vel/127});
      this.events.push({time:n.endSec,   type:'off', note:n.note});
    }
    this.events.sort((a,b)=>a.time-b.time);
    this.nextIdx = 0;
    this.posSec = 0;
    this.t0Ctx = 0;
    this.timer = null;
    this.lookahead = 0.1; // s
    this.running = false;
    this.timeouts = new Set();
    this.onProgressCb = null;
  }
  onProgress(cb){ this.onProgressCb = cb; }
  emitProgress(){ if(this.onProgressCb) this.onProgressCb(this.currentPosition(), this.totalLength()); }
  clearTimers(){
    if(this.timer) clearTimeout(this.timer);
    this.timer = null;
    for(const to of this.timeouts) clearTimeout(to);
    this.timeouts.clear();
  }
  clearPlayingState(){
    this.clearTimers();
    fileNotes.clear();
    if(synth) synth.allNotesOff();
  }
  activateHeldNotes(posSec){
    if(!this.notes || !this.notes.length) return;
    const when = this.ctx.currentTime + 0.001;
    if(!synth) synth=new PolySynth(this.ctx);
    applySeekMuteState();
    for(const n of this.notes){
      if(n.startSec < posSec && n.endSec > posSec){
        const vel = n.vel/127;
        synth.noteOn(n.note, vel, when);
        fileNotes.set(n.note, vel);
      }
    }
  }
  currentPosition(){
    const now = this.running ? (this.ctx.currentTime - this.t0Ctx) : this.posSec;
    return Math.max(0, Math.min(now, this.totalLength()));
  }
  retargetIndex(){
    const pos = this.currentPosition();
    let idx = this.events.findIndex(ev => ev.time >= pos);
    this.nextIdx = idx < 0 ? this.events.length : idx;
  }
  scheduleUntil(tCut){
    const ctx=this.ctx;
    if(!synth) synth=new PolySynth(ctx);
    applySeekMuteState();
    while(this.nextIdx < this.events.length && this.events[this.nextIdx].time <= tCut){
      const ev = this.events[this.nextIdx++];
      const whenAbs = this.t0Ctx + ev.time;
      if(ev.type==='on'){
        synth.noteOn(ev.note, ev.vel||0.8, whenAbs);
        const delay = Math.max(0, (whenAbs - ctx.currentTime))*1000;
        const to = setTimeout(()=>{ fileNotes.set(ev.note, ev.vel||0.8); }, delay);
        this.timeouts.add(to);
      }else{
        synth.noteOff(ev.note, whenAbs);
        const delay = Math.max(0, (whenAbs - ctx.currentTime))*1000;
        const to = setTimeout(()=>{ fileNotes.delete(ev.note); }, delay+5);
        this.timeouts.add(to);
      }
    }
  }
  tick = ()=>{
    if(!this.running) return;
    const now = this.ctx.currentTime - this.t0Ctx;
    this.scheduleUntil(now + this.lookahead);
    this.emitProgress();
    if(now >= this.totalLength()){ this.stop(); return; }
    this.timer = setTimeout(this.tick, 20);
  }
  totalLength(){ return this.events.length? this.events[this.events.length-1].time : 0; }
  play(){
    if(this.running) return;
    this.t0Ctx = this.ctx.currentTime - this.posSec;
    this.running = true;
    this.emitProgress();
    this.activateHeldNotes(this.posSec);
    this.scheduleUntil(this.posSec + this.lookahead);
    this.tick();
  }
  pause(){
    if(!this.running) return;
    this.posSec = this.ctx.currentTime - this.t0Ctx;
    this.retargetIndex();
    this.running = false;
    this.clearTimers();
    this.clearPlayingState();
    this.emitProgress();
  }
  stop(){
    this.running = false; this.posSec = 0; this.nextIdx = 0;
    this.clearPlayingState();
    this.emitProgress();
  }
  setPosition(sec){
    const total = this.totalLength();
    const clamped = Math.max(0, Math.min(Number.isFinite(sec) ? sec : 0, total));
    this.posSec = clamped;
    this.retargetIndex();
    this.clearPlayingState();
    if(this.running){
      this.t0Ctx = this.ctx.currentTime - this.posSec;
      this.activateHeldNotes(this.posSec);
      this.scheduleUntil(this.posSec + this.lookahead);
      this.tick();
    }
    this.emitProgress();
  }
}
/* ===== Trainer（離鍵必須のエッジ検出） ===== */
class GateTrainer{
  constructor(midi){
    this.kind = 'gate';
    this.midi = midi;
    this.steps = midi.onsetTicks.map(tk => ({tick:tk, notes: midi.onsets.get(tk).map(o=>o.note)}));
    this.idx = 0;
    this.active = false;
    this.gateReady = true; // 成立の立ち上がりのみ許可するゲート
  }

  currentNotes(){ return (this.steps[this.idx]?.notes || []).slice().sort((a,b)=>a-b); }

  satisfied(live){
    const t = this.currentNotes();
    if(!t.length) return true;
    for(const n of t){ if(!live.has(n)) return false; }
    return true;
  }

  armAccordingToState(live){
    this.gateReady = !this.satisfied(live); // 既に成立していたら離鍵を要求
  }

  start(live = trainerInputState()){
    this.idx = 0;
    this.active = true;
    this.armAccordingToState(live);
  }

  next(live = trainerInputState()){
    if(!this.active) return;
    this.idx++;
    if(this.idx >= this.steps.length){ this.finish(); return; }
    this.armAccordingToState(live);
  }

  prev(live = trainerInputState()){
    if(!this.active) return;
    this.idx = Math.max(0, this.idx-1);
    this.armAccordingToState(live);
  }

  finish(){ this.active = false; }

  considerAdvance(live = trainerInputState()){
    if(!this.active) return;
    const ok = this.satisfied(live);
    if(!this.gateReady){
      if(!ok) this.gateReady = true; // 一度“不成立”になったら武装
      return;
    }
    if(ok){
      this.gateReady = false;        // 次は必ず離鍵
      this.next(live);
    }
  }
}

/* ===== リアルタイム判定付きリングトレーナー ===== */
class RealTimeTrainer{
  constructor(midi, {toleranceMs = 60, holdRatio = 0.9, lookaheadSec = 2.5} = {}){
    this.kind = 'realtime';
    this.midi = midi;
    this.ctx = ensureCtx();
    this.clock = ()=>performance.now()/1000;
    this.applyOptions({toleranceMs, holdRatio, lookaheadSec});
    this.resetState();
  }
  applyOptions({toleranceMs, holdRatio, lookaheadSec} = {}){
    this.toleranceSec = Math.max(0.005, (toleranceMs ?? 60) / 1000);
    this.holdRatio = Math.max(0, holdRatio ?? 0.9);
    this.lookaheadSec = Math.max(0.5, lookaheadSec ?? 2.5);
  }
  resetState(){
    this.notes = (this.midi?.notes || []).map((n, idx)=>({
      ...n,
      idx,
      len: Math.max(0.05, n.endSec - n.startSec),
      state: 'pending',
      actualOn: null
    }));
    this.firstNoteSec = this.notes.reduce((m,n)=>Math.min(m, n.startSec??Infinity), Infinity);
    this.running = false;
    this.active = false;
    this.startCtxTime = 0;
    this.monotonicStart = 0;
    this.posSec = 0;
    this.stats = {perfect:0, good:0, miss:0, early:0, late:0, holdOk:0, holdMiss:0};
    this.deltaSum = 0;
    this.deltaCount = 0;
  }
  totalLength(){ return this.midi?.lengthSec || 0; }
  start(){
    if(!this.ctx) this.ctx = ensureCtx();
    try{ if(this.ctx && this.ctx.state==='suspended') this.ctx.resume(); }catch{}
    this.resetState();
    this.startCtxTime = this.ctx ? this.ctx.currentTime : 0;
    this.monotonicStart = this.clock();
    this.posSec = 0;
    this.running = true;
    this.active = true;
  }
  stop(){
    this.running = false;
    this.active = false;
    this.posSec = 0;
  }
  now(){
    if(!this.running) return this.posSec;
    const base = (this.ctx && this.ctx.state==='running')
      ? (this.ctx.currentTime - this.startCtxTime)
      : (this.clock() - this.monotonicStart);
    const pos = Number.isFinite(base) ? base : 0;
    return Math.max(0, Math.min(pos, this.totalLength()));
  }
  _markMiss(target){
    target.state = 'miss';
    this.stats.miss++;
  }
  _evalHold(target, nowSec){
    if(target.state !== 'on') return;
    const refNow = nowSec != null ? nowSec : this.now();
    const held = Math.max(0, refNow - (target.actualOn ?? refNow));
    const ratio = held / Math.max(0.05, target.len);
    if(ratio >= this.holdRatio){
      this.stats.holdOk++;
    }else{
      this.stats.holdMiss++;
    }
    target.state = 'done';
  }
  _handleOn(note, relSec){
    const tol = this.toleranceSec;
    let pick = null, best = Infinity, delta = 0;
    for(const n of this.notes){
      if(n.state!=='pending' || n.note!==note) continue;
      const d = relSec - n.startSec;
      const abs = Math.abs(d);
      if(abs <= tol && abs < best){
        pick = n; best = abs; delta = d;
      }
    }
    if(pick){
      pick.state = 'on';
      pick.actualOn = relSec;
      this.deltaSum += delta;
      this.deltaCount++;
      if(Math.abs(delta) <= tol*0.35){
        this.stats.perfect++;
      }else{
        this.stats.good++;
      }
      if(delta > 0.001) this.stats.late++; else if(delta < -0.001) this.stats.early++;
    }else{
      this.stats.miss++;
    }
  }
  _handleOff(note, relSec){
    const target = this.notes.find(n=>n.state==='on' && n.note===note);
    if(!target) return;
    this._evalHold(target, relSec);
  }
  processInput(note, type, vel, timeSec = null){
    if(!this.active) return;
    const abs = (timeSec!=null) ? timeSec
      : ((this.ctx && this.ctx.state==='running') ? this.ctx.currentTime : this.clock());
    const relSec = abs - (this.ctx && this.ctx.state==='running' ? this.startCtxTime : this.monotonicStart);
    if(type==='on') this._handleOn(note, relSec);
    else this._handleOff(note, relSec);
  }
  advance(nowSec = this.now()){
    const tol = this.toleranceSec;
    for(const n of this.notes){
      if(n.state==='pending' && nowSec > n.startSec + tol){
        this._markMiss(n);
      }else if(n.state==='on' && nowSec > n.endSec + tol){
        this._evalHold(n, nowSec);
      }
    }
    if(nowSec >= this.totalLength() + tol){
      this.active = false;
      this.running = false;
    }
  }
  segments(nowSec = this.now(), lookahead = this.lookaheadSec){
    const end = nowSec + lookahead;
    return this.notes.filter(n=>{
      if(n.state==='done' || n.state==='miss') return false;
      return n.startSec >= nowSec - this.toleranceSec && n.startSec <= end;
    });
  }
  summary(){
    const hits = this.stats.perfect + this.stats.good;
    const avgMs = this.deltaCount ? (this.deltaSum / this.deltaCount * 1000) : 0;
    return {...this.stats, hits, avgMs, total:this.notes.length};
  }
}
  /* ===== UI actions ===== */
  btnPlay.onclick = ()=>{
  if(!midiData){ fileInfo.textContent='file: –'; return; }
  const ctx = ensureCtx();
  try{ if(ctx.state==='suspended') ctx.resume(); }catch{}
  if(!player){
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
  }
  // 再生完了後は先頭から再生成、途中停止ならその位置から再開
  if(player.posSec >= player.totalLength()){
    player.stop();
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
  }
  player.play();
};
btnPause.onclick = ()=>{ if(player) player.pause(); };
btnStop.onclick = ()=>{ if(player) player.stop(); };
const beginSeekInteraction = ()=>{
  seekWasRunning = !!(player && player.running);
  if(player) player.pause();
  if(!seekMuting){ seekMuting = true; applySeekMuteState(); }
};
const endSeekInteraction = ()=>{
  if(seekMuting){ seekMuting = false; applySeekMuteState(); }
  if(seekWasRunning && player){ player.play(); }
  seekWasRunning = false;
};
seekSlider.addEventListener('pointerdown', beginSeekInteraction);
seekSlider.addEventListener('pointerup', endSeekInteraction);
seekSlider.addEventListener('pointercancel', endSeekInteraction);
addEventListener('pointerup', endSeekInteraction);
addEventListener('pointercancel', endSeekInteraction);
seekSlider.addEventListener('input', ()=>{
  if(!midiData) return;
  if(!player){
    const ctx = ensureCtx();
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
  }
  const raw = parseFloat(seekSlider.value);
  const frac = Math.max(0, Math.min(1, Number.isNaN(raw) ? 0 : raw / 1000));
  const target = frac * player.totalLength();
  if(Number.isFinite(target)) player.setPosition(target);
});

btnStartTrain.onclick = ()=>{
  if(!midiData && midiDataRaw){
    midiData = applyTransposeToMIDI(midiDataRaw, midiTranspose);
  }
  if(!midiData){
    fileInfo.textContent='file: –';
    trainerStat.textContent = 'ring: MIDI file not loaded';
    return;
  }
  if(player) player.stop();
  trainer = buildTrainerForMode();
  if(trainer){
    if(trainer.kind === 'gate'){
      trainer.start(trainerInputState());   // 開始時点の押下状態でゲート初期化
    }else if(trainer.kind === 'realtime'){
      trainer.applyOptions({toleranceMs: timingToleranceMs, holdRatio: holdTolerancePct/100, lookaheadSec: ringLookaheadSec});
      trainer.start();
      const n = Array.isArray(trainer.notes) ? trainer.notes.length : 0;
      trainerStat.textContent = `ring: ready (${n} notes)`;
    }
  }
  if(!trainer){
    trainerStat.textContent = 'ring: failed to init (no MIDI data)';
  }else if(trainer.kind === 'realtime'){
    const total = trainer.midi?.notes?.length || 0;
    trainerStat.textContent = `ring: ready (${total} notes)`;
  }
  updateTrainerUI();
};
btnPrev.onclick = ()=>{ if(trainer && trainer.active && trainer.kind==='gate'){ trainer.prev(trainerInputState()); updateTrainerUI(); } };
btnNext.onclick = ()=>{ if(trainer && trainer.active && trainer.kind==='gate'){ trainer.next(trainerInputState()); updateTrainerUI(); } };

function updateTrainerUI(){
  if(trainer && trainer.active){
    if(trainer.kind === 'gate'){
      const tn = trainer.currentNotes();
      trainerStat.textContent = `step: ${trainer.idx+1}/${trainer.steps.length}  notes: [${tn.join(', ')}]`;
    }else if(trainer.kind === 'realtime'){
      const s = trainer.summary();
      const holdTotal = s.holdOk + s.holdMiss;
      const holdTxt = holdTotal ? `${s.holdOk}/${holdTotal}` : '–';
      const deltaTxt = Number.isFinite(s.avgMs) ? `${s.avgMs.toFixed(1)} ms` : '–';
      const wait = Number.isFinite(trainer.firstNoteSec) ? `t0=${trainer.firstNoteSec.toFixed(2)}s` : '';
      trainerStat.textContent = `ring: hit ${s.hits}/${s.total}  Δ=${deltaTxt}  hold ${holdTxt} ${wait}`;
    }
  }else if(trainer && !trainer.active){
    if(trainer.kind === 'realtime'){
      const s = trainer.summary();
      const holdTotal = s.holdOk + s.holdMiss;
      const holdTxt = holdTotal ? `${s.holdOk}/${holdTotal}` : '–';
      const deltaTxt = Number.isFinite(s.avgMs) ? `${s.avgMs.toFixed(1)} ms` : '–';
      const hasResult = (s.hits + s.miss + holdTotal + s.early + s.late) > 0;
      trainerStat.textContent = hasResult ? `ring done: ${s.hits}/${s.total}  Δ=${deltaTxt}  hold ${holdTxt}` : 'ring: –';
    }else{
      trainerStat.textContent = `step: done (${trainer?.steps?.length||0})`;
    }
  }else{
    trainerStat.textContent = 'step: –';
  }
}

/* ===== Keyboard shortcuts ===== */
addEventListener('keydown', e=>{
  if(fileOp.value==='train' && trainer && trainer.active && trainer.kind==='gate'){
    if(e.key==='ArrowLeft'){ trainer.prev(trainerInputState()); updateTrainerUI(); }
    else if(e.key==='ArrowRight'){ trainer.next(trainerInputState()); updateTrainerUI(); }
  }
});
</script>
