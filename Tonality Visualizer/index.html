<!-- Copyright (c) 2025 Yusuke Yoshida — MIT License
-->
<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<title>Polar Pitch Map — Disk physics, MIDI In + MIDI File</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ddd;font:14px system-ui}
  :root{ --ui-scale:1; }
  #ui{position:fixed;top:75px;left:8px;gap:12px;display:flex;flex-wrap:wrap;align-items:center;z-index:2;
       transform-origin:top left; transform:scale(var(--ui-scale));
       max-height:calc(100vh - 110px); overflow-y:auto; -webkit-overflow-scrolling:touch; padding:4px 6px;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}
  label{display:flex;gap:6px;align-items:center}
  input[type=range]{width:180px}
  button,select{padding:6px 10px}
  .sep{width:1px;height:22px;background:#444;margin:0 4px}

  /* UI show/hide トグル */
  #uiToggle{position:fixed;top:50px;right:8px;z-index:3;opacity:0.8}
  #uiToggle:hover{opacity:1}
</style>

<button id="uiToggle" aria-pressed="false">UI隠す</button>

<div id="ui">
  <!-- language -->
  <label id="langWrap" data-lbl="language">
    <select id="lang">
      <option value="en">English</option>
      <option value="ja" selected>日本語</option>
    </select>
  </label>

  <button id="resetSettings" type="button">初期設定に戻す</button>

  <!-- anchor: 水面固定 or ディスク固定 -->
  <label id="anchorWrap" data-lbl="anchor">
    <select id="anchor">
      <option value="water">水面固定</option>
      <option value="disk">ディスク固定</option>
    </select>
  </label>

  <!-- MIDI inputs（常時） -->
  <label id="devWrap" data-lbl="device">
    <select id="midiDev"></select>
  </label>
  <label id="allWrap" data-lbl="allInputs">
    <input id="midiAll" type="checkbox" checked>
  </label>

  <!-- ライブ入力の音声再生ON/OFF -->
  <label id="liveMonWrap" data-lbl="liveSound">
    <input id="liveMon" type="checkbox" checked>
  </label>

  <!-- torque scope -->
  <label id="excludeWrap" data-lbl="torqueExclude">
    <select id="exclude">
      <option value="filled">塗りつぶし</option>
      <option value="unfilled" selected>非塗りつぶし</option>
    </select>
  </label>

  <!-- ω max（対数目盛：0.01〜100 rad/s） -->
  <label id="omaxWrap" data-lbl="omegaMax">
    <input id="omegaMax" type="range" min="-2" max="2" step="0.01" value="0.301" list="omTicks">
    <datalist id="omTicks">
      <option value="-2"><option value="-1"><option value="0"><option value="1"><option value="2">
    </datalist>
    <span id="omegaMaxVal">2.00 rad/s</span>
  </label>

  <!-- damping（比例：0〜99 %/s） -->
  <label id="dampWrap" data-lbl="damping">
    <input id="damp" type="range" min="0" max="99" step="0.001" value="99" list="dampTicks">
    <datalist id="dampTicks">
      <option value="0"><option value="25"><option value="50"><option value="75"><option value="99">
    </datalist>
    <span id="dampVal">99%/s</span>
  </label>

  <!-- snap ω when α=0 -->
  <label id="snapAlphaWrap" data-lbl="snapZeroAlpha">
    <input id="snapAlpha" type="checkbox" checked>
  </label>

  <!-- UI opacity -->
  <label id="uiopWrap" data-lbl="uiOpacity">
    <input id="uiop" type="range" min="10" max="100" step="1" value="85">
    <span id="uiopVal">85%</span>
  </label>

  <!-- disk physics -->
  <label id="massWrap" data-lbl="diskMass">
    <input id="mass" type="range" min="-2" max="2" step="0.001" value="-0.431">
    <span id="massVal">M=0.37</span>
  </label>

  <label id="lowCutWrap" data-lbl="lowCut">
    <input id="lowCut" type="range" min="0" max="6" step="1" value="0" list="lowCutTicks">
    <datalist id="lowCutTicks">
      <option value="0"><option value="1"><option value="2"><option value="3"><option value="4"><option value="5"><option value="6">
    </datalist>
    <span id="lowCutVal">0</span>
  </label>

  <label id="highCutWrap" data-lbl="highCut">
    <input id="highCut" type="range" min="0" max="6" step="1" value="0" list="highCutTicks">
    <datalist id="highCutTicks">
      <option value="0"><option value="1"><option value="2"><option value="3"><option value="4"><option value="5"><option value="6">
    </datalist>
    <span id="highCutVal">0</span>
  </label>

  <!-- visuals -->
  <label id="lineAWrap" data-lbl="lineAlpha">
    <input id="lineA" type="range" min="0" max="100" step="1" value="50">
    <span id="lineAVal">50%</span>
  </label>

  <label id="straightLineAWrap" data-lbl="straightLineAlpha">
    <input id="straightLineA" type="range" min="0" max="100" step="1" value="20">
    <span id="straightLineAVal">20%</span>
  </label>

  <label id="noteGuideAWrap" data-lbl="noteGuideAlpha">
    <input id="noteGuideA" type="range" min="0" max="100" step="1" value="15">
    <span id="noteGuideAVal">15%</span>
  </label>

  <label id="noteGuideLabelAWrap" data-lbl="noteGuideLabelAlpha">
    <input id="noteGuideLabelA" type="range" min="0" max="100" step="1" value="5">
    <span id="noteGuideLabelAVal">5%</span>
  </label>

  <label id="waterAWrap" data-lbl="waterAlpha">
    <input id="waterA" type="range" min="0" max="100" step="1" value="15">
    <span id="waterAVal">15%</span>
  </label>

  <label id="movNumAWrap" data-lbl="movNumAlpha">
    <input id="movNumA" type="range" min="0" max="100" step="1" value="28">
    <span id="movNumAVal">28%</span>
  </label>

  <label id="movNumSizeWrap" data-lbl="movNumSize">
    <input id="movNumSize" type="range" min="10" max="60" step="1" value="28">
    <span id="movNumSizeVal">28px</span>
  </label>

  <label id="labelSizeWrap" data-lbl="labelSize">
    <input id="labelSize" type="range" min="8" max="36" step="1" value="12">
    <span id="labelSizeVal">12px</span>
  </label>

  <label id="labelBGWrap" data-lbl="labelBG">
    <input id="labelBG" type="range" min="0" max="100" step="1" value="0">
    <span id="labelBGVal">0%</span>
  </label>

  <label id="labelAlphaWrap" data-lbl="labelAlpha">
    <input id="labelAlpha" type="range" min="0" max="100" step="1" value="0">
    <span id="labelAlphaVal">0%</span>
  </label>

  <!-- MIDI File controls（常時表示） -->
  <span class="sep"></span>
  <label id="fileWrap" data-lbl="midiFile">
    <input id="midiFile" type="file" accept=".mid,.midi,audio/midi,audio/x-midi">
  </label>
  <label id="transposeWrap" data-lbl="transpose">
    <input id="transpose" type="range" min="-6" max="6" step="1" value="0">
    <span id="transposeVal">+0 半音</span>
  </label>
  <label id="fileOpWrap" data-lbl="fileOp">
    <select id="fileOp">
      <option value="play">再生</option>
      <option value="train" selected>トレーナー</option>
    </select>
  </label>
  <span id="playBtns">
    <button id="btnPlay">▶︎</button>
    <button id="btnPause">⏸</button>
    <button id="btnStop">⏹</button>
  </span>
  <label id="seekWrap" data-lbl="seek">
    <input id="seek" type="range" min="0" max="1000" step="0.01" value="0" disabled>
    <span id="seekTime">0:00 / 0:00</span>
  </label>
  <span id="trainBtns">
    <button id="btnStartTrain">開始/リスタート</button>
    <button id="btnPrev">◀︎</button>
    <button id="btnNext">▶︎</button>
  </span>

  <span id="info">idle</span>
  <span id="midiStat" style="min-width:280px">MIDI: 未初期化</span>
  <span id="midiLast">最後: –</span>
  <span id="fileInfo">file: –</span>
  <span id="trainerStat">step: –</span>
</div>

<canvas id="cv"></canvas>

<script>
/* ===== UI scaling ===== */
// iPhoneでUIが縮みすぎないようにスケール調整する
const isIPhone = /iPhone/i.test(navigator.userAgent);
if (isIPhone) {
  document.documentElement.style.setProperty('--ui-scale', '0.75');
  document.body.classList.add('ios');
}

/* ===== Canvas ===== */
// メインキャンバスの初期化とリサイズ処理
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
// ウィンドウの大きさに応じてキャンバスをリサイズし、Retina解像度にも対応
function resize(){ cv.width = innerWidth*devicePixelRatio; cv.height = innerHeight*devicePixelRatio; }
addEventListener('resize', resize); resize();

/* ===== Music constants ===== */
// 周波数と描画範囲に関する定数群
const F_LOW = 27.5, F_HIGH = 4186.009;
const OCTAVES = Math.ceil(Math.log2(F_HIGH/F_LOW));
const MARGIN = 80;                               // 余白を広めに
const ANG0 = Math.PI/2;                          // Cを上（0°相当）
const GRAV_ABS = ANG0;                           // 重力方向=0°固定
const EXCLUDE_PAD_RAD = 0.1 * Math.PI / 180;       // 無効領域+0.1°
const LABEL_ENH = {0:"C",1:"C#/Db",2:"D",3:"D#/Eb",4:"E",5:"F",6:"F#/Gb",7:"G",8:"G#/Ab",9:"A",10:"A#/Bb",11:"B"};
// 完全5度圏の配置を事前計算しておく
const FIFTH_ORDER_PCS = (()=>{ let a=[],pc=0; for(let k=0;k<12;k++){ a.push(pc); pc=(pc+7)%12; } return a; })();
const FIFTH_INDEX = (()=>{ const m=Array(12).fill(0); FIFTH_ORDER_PCS.forEach((pc,i)=>m[pc]=i); return m; })();
const FIFTH_LABELS = FIFTH_ORDER_PCS.map(pc=>LABEL_ENH[pc]);
const NOTE_BG = {0:[191,28,28],1:[191,109,28],2:[191,191,28],3:[109,191,28],4:[28,191,28],5:[28,191,109],6:[28,191,191],7:[28,109,191],8:[28,28,191],9:[109,28,191],10:[191,28,191],11:[191,28,109]};

/* ===== UI refs ===== */
// UI要素の参照をまとめて保持
const uiPanel = document.getElementById('ui');
const uiToggle = document.getElementById('uiToggle');
const anchorSel = document.getElementById('anchor');
const devWrap = document.getElementById('devWrap');
const midiDev = document.getElementById('midiDev');
const allWrap = document.getElementById('allWrap');
const midiAll = document.getElementById('midiAll');
const liveMon = document.getElementById('liveMon');
const resetBtn = document.getElementById('resetSettings');

const excludeSel = document.getElementById('exclude');
const uiopSlider = document.getElementById('uiop'); const uiopVal = document.getElementById('uiopVal');
const massSlider = document.getElementById('mass'); const massVal = document.getElementById('massVal');
const dampSlider = document.getElementById('damp'); const dampVal = document.getElementById('dampVal');
const snapAlphaCheckbox = document.getElementById('snapAlpha');
const info = document.getElementById('info');
const midiStat = document.getElementById('midiStat'); const midiLast = document.getElementById('midiLast');
const lowCutSlider = document.getElementById('lowCut'); const lowCutVal = document.getElementById('lowCutVal');
const highCutSlider = document.getElementById('highCut'); const highCutVal = document.getElementById('highCutVal');
const lineASlider = document.getElementById('lineA'); const lineAVal = document.getElementById('lineAVal');
const straightLineASlider = document.getElementById('straightLineA'); const straightLineAVal = document.getElementById('straightLineAVal');
const noteGuideASlider = document.getElementById('noteGuideA'); const noteGuideAVal = document.getElementById('noteGuideAVal');
const noteGuideLabelASlider = document.getElementById('noteGuideLabelA'); const noteGuideLabelAVal = document.getElementById('noteGuideLabelAVal');
const waterASlider = document.getElementById('waterA'); const waterAVal = document.getElementById('waterAVal');
const labelSizeSlider = document.getElementById('labelSize'); const labelSizeVal = document.getElementById('labelSizeVal');
const labelBGSlider = document.getElementById('labelBG'); const labelBGVal = document.getElementById('labelBGVal');
const labelAlphaSlider = document.getElementById('labelAlpha'); const labelAlphaVal = document.getElementById('labelAlphaVal');
const movNumASlider = document.getElementById('movNumA'); const movNumAVal = document.getElementById('movNumAVal');
const movNumSizeSlider = document.getElementById('movNumSize'); const movNumSizeVal = document.getElementById('movNumSizeVal');

const omegaMaxSlider = document.getElementById('omegaMax'); const omegaMaxVal = document.getElementById('omegaMaxVal');

const midiFileInput = document.getElementById('midiFile');
const fileOp = document.getElementById('fileOp');
const btnPlay = document.getElementById('btnPlay');
const btnPause = document.getElementById('btnPause');
const btnStop = document.getElementById('btnStop');
const btnStartTrain = document.getElementById('btnStartTrain');
const btnPrev = document.getElementById('btnPrev');
const btnNext = document.getElementById('btnNext');
const fileInfo = document.getElementById('fileInfo');
const trainerStat = document.getElementById('trainerStat');
const transposeSlider = document.getElementById('transpose');
const transposeVal = document.getElementById('transposeVal');
const seekSlider = document.getElementById('seek');
const seekTime = document.getElementById('seekTime');

function reserveValueWidths(){
  const reserve = (el, samples)=>{
    if(!el || !samples || !samples.length) return;
    const probe = document.createElement('span');
    probe.style.visibility = 'hidden';
    probe.style.position = 'absolute';
    probe.style.whiteSpace = 'pre';
    probe.style.font = 'inherit';
    probe.style.fontVariantNumeric = 'tabular-nums';
    uiPanel.appendChild(probe);
    let maxWidth = 0;
    for(const text of samples){
      probe.textContent = text;
      const w = probe.getBoundingClientRect().width;
      if(w > maxWidth) maxWidth = w;
    }
    uiPanel.removeChild(probe);
    el.style.display = 'inline-block';
    el.style.minWidth = `${Math.ceil(maxWidth)}px`;
    el.style.textAlign = 'right';
    el.style.fontVariantNumeric = 'tabular-nums';
  };

  reserve(omegaMaxVal, ['0.0100 rad/s', '100 rad/s']);
  reserve(dampVal, ['0%/s', '99%/s']);
  reserve(uiopVal, ['100%']);
  reserve(massVal, ['M=0.01', 'M=100.00']);
  reserve(lowCutVal, ['0オクターブ', '6オクターブ', '6 oct']);
  reserve(highCutVal, ['0オクターブ', '6オクターブ', '6 oct']);
  const pctSamples = ['0%', '100%'];
  reserve(lineAVal, pctSamples);
  reserve(straightLineAVal, pctSamples);
  reserve(noteGuideAVal, pctSamples);
  reserve(noteGuideLabelAVal, pctSamples);
  reserve(waterAVal, pctSamples);
  reserve(movNumAVal, pctSamples);
  reserve(labelBGVal, pctSamples);
  reserve(labelAlphaVal, pctSamples);
  reserve(movNumSizeVal, ['10px', '60px']);
  reserve(labelSizeVal, ['8px', '36px']);
}
reserveValueWidths();

/* ===== i18n + persist ===== */
// 言語切り替え用の辞書データ
const I18N = {
  en:{
    language:"language", device:"device", allInputs:"All inputs",
    anchor:"anchor", waterFixed:"water fixed", diskFixed:"disk fixed",
    liveSound:"monitor live MIDI",
    torqueExclude:"Torque exclusion", filled:"filled", unfilled:"unfilled",
    uiOpacity:"UI opacity", diskMass:"disk mass", damping:"damping",
    snapZeroAlpha:"zero ω when α=0",
    lineAlpha:"line α", straightLineAlpha:"straight lines α", noteGuideAlpha:"note guide α", noteGuideLabelAlpha:"note guide numbers α", waterAlpha:"water α", movNumAlpha:"degree numbers α", movNumSize:"degree numbers size",
    labelSize:"label size", labelBG:"label bg α", labelAlpha:"label text α",
    lowCut:"low cut (oct)", highCut:"high cut (oct)",
    omegaMax:"ω max",
    midiNotInit:"MIDI: not initialized", last:"last:", idle:"idle",
    midiNeedSecure:"need HTTPS/localhost", midiUnsupported:"unsupported",
    midiReady:"ready", midiInitFailed:"init failed", midiAllInputsStat:"all inputs",
    midiInputStatPrefix:"input:", midiNoDevice:"no device",
    midiFile:"MIDI file", fileOp:"operation", play:"playback", train:"trainer",
    trainStart:"start / restart", transpose:"transpose",
    seek:"position",
    resetDefaults:"reset settings"
  },
  ja:{
    language:"言語", device:"デバイス", allInputs:"全入力",
    anchor:"固定", waterFixed:"水面固定", diskFixed:"ディスク固定",
    liveSound:"MIDI入力の音声再生",
    torqueExclude:"トルク無効領域", filled:"塗りつぶし", unfilled:"非塗りつぶし",
    uiOpacity:"UI不透明度", diskMass:"ディスク質量", damping:"ダンピング",
    snapZeroAlpha:"α=0で角速度を停止",
    lineAlpha:"曲線の不透明度", straightLineAlpha:"直線の不透明度", noteGuideAlpha:"音ガイドの不透明度", noteGuideLabelAlpha:"音ガイド数字の不透明度", waterAlpha:"水面の不透明度", movNumAlpha:"移動ド数字の不透明度", movNumSize:"移動ド数字サイズ",
    labelSize:"ラベルサイズ", labelBG:"ラベル背景の不透明度", labelAlpha:"音名の不透明度",
    lowCut:"低音域カット", highCut:"高音域カット",
    omegaMax:"最大回転速度",
    midiNotInit:"MIDI: 未初期化", last:"最後:", idle:"待機",
    midiNeedSecure:"HTTPS/localhostが必要", midiUnsupported:"未対応",
    midiReady:"準備完了", midiInitFailed:"初期化失敗", midiAllInputsStat:"全入力",
    midiInputStatPrefix:"入力:", midiNoDevice:"デバイスなし",
    midiFile:"MIDIファイル", fileOp:"操作", play:"再生", train:"トレーナー",
    trainStart:"開始/リスタート", transpose:"移調",
    seek:"再生位置",
    resetDefaults:"初期設定に戻す"
  }
};
const SETTINGS_KEY = 'ppm:v6';
// 初回ロード時のデフォルト設定をキャッシュ
let DEFAULT_SETTINGS = null;

// UIスケールと初期言語
let uiScale = 0.95;
let lang = (navigator.language||'en').startsWith('ja') ? 'ja' : 'en';
let midiTranspose = 0;
function t(k){ return (I18N[lang]&&I18N[lang][k]) || I18N.en[k] || k; }
// ラベル要素に翻訳済みテキストを設定
function setLabelText(labelEl, key){
  if(!labelEl) return;
  if(labelEl.firstChild && labelEl.firstChild.nodeType===Node.TEXT_NODE){
    labelEl.firstChild.nodeValue = t(key)+' ';
  }else{
    labelEl.prepend(document.createTextNode(t(key)+' '));
  }
}
// HTML全体のCSSカスタムプロパティに反映してUIのサイズを切り替える
function applyUIScale(){ document.documentElement.style.setProperty('--ui-scale', uiScale); }
// ラベルやステータスの文言を現在の言語設定で書き換える
function applyI18N(){
  document.documentElement.lang = lang;
  // data-lbl属性を持つすべての要素に翻訳済みの文字列を注入
  document.querySelectorAll('[data-lbl]').forEach(el=> setLabelText(el, el.getAttribute('data-lbl')));
  anchorSel.querySelector('option[value="water"]').textContent = t('waterFixed');
  anchorSel.querySelector('option[value="disk"]').textContent  = t('diskFixed');
  excludeSel.querySelector('option[value="filled"]').textContent   = t('filled');
  excludeSel.querySelector('option[value="unfilled"]').textContent = t('unfilled');
  fileOp.querySelector('option[value="play"]').textContent = t('play');
  fileOp.querySelector('option[value="train"]').textContent = t('train');
  btnStartTrain.textContent = t('trainStart');
  if(resetBtn) resetBtn.textContent = t('resetDefaults');
  uiToggle.textContent = uiVisible ? 'UI隠す' : 'UI表示';
  updateCutDisplays();
  updateTransposeDisplay();
  document.getElementById('lang').value = lang;
  info.textContent = t('idle');
  midiStat.textContent = t('midiNotInit');
  midiLast.textContent = t('last') + ' –';
}
// 言語選択ドロップダウンの変更ハンドラ
document.getElementById('lang').addEventListener('change', e=>{
  lang = e.target.value==='ja' ? 'ja' : 'en';
  applyI18N(); saveSettings();
});

// UIの状態をオブジェクトにまとめて保存用に返す
function collectSettingsFromUI(){
  // 保存対象のプロパティを列挙
  return {
    lang, uiScale,
    anchor: anchorSel.value, midiAll: midiAll.checked, liveMon: liveMon.checked,
    uiop: uiopSlider.value, mass: massSlider.value,
    lineA: lineASlider.value, straightLineA: straightLineASlider.value, waterA: waterASlider.value,
    noteGuideA: noteGuideASlider.value,
    noteGuideLabelA: noteGuideLabelASlider.value,
    movNumA: movNumASlider.value, movNumSize: movNumSizeSlider.value,
    labelSize: labelSizeSlider.value, labelBG: labelBGSlider.value,
    labelAlpha: labelAlphaSlider.value,
    exclude: excludeSel.value,
    lowCut: lowCutOct,
    highCut: highCutOct,
    omegaMaxExp: omegaMaxSlider.value,
    midiTranspose,
    dampPct: dampSlider.value,
    snapZeroAlpha: snapAlphaCheckbox.checked,
    fileOp: fileOp.value,
    uiHidden: !uiVisible
  };
}

// localStorageへ設定を保存（例外は握りつぶす）
function saveSettings(){
  try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectSettingsFromUI())); }catch{}
}
// 保存された設定をUIに反映する
function applySettings(settings, {force = false} = {}){
  const s = (settings && typeof settings === 'object') ? settings : {};
  const has = key => force ? (key in s) : (s[key] != null);

  // 言語関連の復元
  if(has('lang')){
    lang = s.lang === 'ja' ? 'ja' : 'en';
  }
  // UIスケール関連の復元
  if(has('uiScale')){
    const parsed = parseFloat(s.uiScale);
    if(!Number.isNaN(parsed)) uiScale = parsed;
  }
  // ここから下は順番依存のため見通しを良くするため小分けにコメントを挿入
  // アンカーやMIDI関連の復元
  if(has('anchor') && s.anchor){
    anchorSel.value = s.anchor;
  }
  if(has('midiAll')){
    midiAll.checked = !!s.midiAll;
  }
  if(has('liveMon')){
    liveMon.checked = !!s.liveMon;
  }
  // 視覚設定の値を順番に反映
  if(has('uiop')){
    uiopSlider.value = s.uiop;
    applyUIOpacity();
  }
  if(has('mass')){
    massSlider.value = s.mass;
    updateMass();
  }
  if(has('lineA')){
    lineASlider.value = s.lineA;
    lineASlider.oninput();
  }
  if(has('straightLineA')){
    straightLineASlider.value = s.straightLineA;
    straightLineASlider.oninput();
  }
  if(has('waterA')){
    waterASlider.value = s.waterA;
    waterASlider.oninput();
  }
  if(has('noteGuideA')){
    noteGuideASlider.value = s.noteGuideA;
    noteGuideASlider.oninput();
  }
  if(has('noteGuideLabelA')){
    noteGuideLabelASlider.value = s.noteGuideLabelA;
    noteGuideLabelASlider.oninput();
  }
  if(has('movNumA')){
    movNumASlider.value = s.movNumA;
    movNumASlider.oninput();
  }
  if(has('movNumSize')){
    movNumSizeSlider.value = s.movNumSize;
    movNumSizeSlider.oninput();
  }
  if(has('labelSize')){
    labelSizeSlider.value = s.labelSize;
    labelSizeSlider.oninput();
  }
  if(has('labelBG')){
    labelBGSlider.value = s.labelBG;
    labelBGSlider.oninput();
  }
  if(has('labelAlpha')){
    labelAlphaSlider.value = s.labelAlpha;
    labelAlphaSlider.oninput();
  }
  if(has('exclude')){
    excludeSel.value = s.exclude;
  }
  if(has('lowCut')){
    // 入力値は整数として扱い、NaNなら0に戻す
    const value = parseInt(s.lowCut,10);
    applyLowCut(Number.isNaN(value) ? 0 : value, false);
  }
  if(has('highCut')){
    // 高域の制限も同様に安全な範囲へクランプ
    const value = parseInt(s.highCut,10);
    applyHighCut(Number.isNaN(value) ? 0 : value, false);
  }
  if(has('omegaMaxExp')){
    omegaMaxSlider.value = s.omegaMaxExp;
    applyOmegaMaxFromSlider();
  }
  if(has('midiTranspose')){
    const value = parseInt(s.midiTranspose,10);
    const clamped = Math.max(-6, Math.min(6, Number.isNaN(value) ? 0 : value));
    midiTranspose = clamped;
    transposeSlider.value = String(clamped);
    applyTransposeSetting({shouldSave:false, preservePlayback:false});
  }
  if(has('dampPct')){
    dampSlider.value = s.dampPct;
  }else if(!force && s.dampExp!=null){
    const exp = parseFloat(s.dampExp);
    if(!Number.isNaN(exp)){
      const q = Math.min(99, Math.max(0.001, Math.pow(10, exp)));
      const p = 100 - q;
      dampSlider.value = Math.min(99, Math.max(0, p));
    }
  }
  if(has('snapZeroAlpha')){
    snapAlphaCheckbox.checked = !!s.snapZeroAlpha;
  }
  if(has('fileOp')){
    fileOp.value = s.fileOp;
  }
  if(has('uiHidden')){
    uiVisible = !s.uiHidden;
    updateUIVisibility();
  }
}

function loadSettings(){
  let stored = {};
  try{
    // localStorageから設定文字列を取得し、壊れていてもアプリが落ちないようにする
    stored = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}') || {};
  }catch{}
  applySettings(stored);
  applyUIScale();
  applyI18N();
  snapZeroAlpha = snapAlphaCheckbox.checked;
  updateDampFromSlider();
  updateFileOpUI();
}

/* ===== UI show/hide ===== */
let uiVisible = true;
function updateUIVisibility(){
  // displayプロパティで丸ごとパネルを非表示にする
  uiPanel.style.display = uiVisible ? '' : 'none';
  uiToggle.setAttribute('aria-pressed', String(!uiVisible));
  uiToggle.textContent = uiVisible ? 'UI隠す' : 'UI表示';
}
// ボタン操作時は状態をトグルして即座に保存
uiToggle.onclick = ()=>{ uiVisible = !uiVisible; updateUIVisibility(); saveSettings(); };
// キーボードショートカット（Uキー）での開閉をサポート
addEventListener('keydown', e=>{ if(e.key==='u' || e.key==='U'){ uiVisible = !uiVisible; updateUIVisibility(); saveSettings(); }});

/* ファイル操作UIの表示切替（再生 or トレーナー） */
function updateFileOpUI(){
  const isPlay = (fileOp.value === 'play');
  // 再生モードでは再生ボタン群、トレーナーモードでは練習用ボタン群だけを見せる
  document.getElementById('playBtns').style.display  = isPlay ? '' : 'none';
  document.getElementById('trainBtns').style.display = isPlay ? 'none' : '';
  if(isPlay){
    // 再生モード時は最新の進行状況を再生ステータスで置き換える
    info.textContent = 'file playback';
  }else{
    // トレーナーモードに切り替わると進捗インジケータを初期化
    trainerStat.textContent = 'step: –';
  }
}
fileOp.addEventListener('change', ()=>{ updateFileOpUI(); saveSettings(); });

/* ===== Helpers ===== */
function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }
function ringParams(){
  const half = Math.max(1, Math.min(cv.width, cv.height) / 2);
  const safeHalf = Math.max(1, half - 4);
  let rMax = half - MARGIN;
  if(!Number.isFinite(rMax)) rMax = safeHalf;
  if(rMax < 1) rMax = safeHalf;
  rMax = Math.max(1, Math.min(rMax, safeHalf));
  const octaves = activeOctaveCount();
  const minRadius = (highCutOct > 0) ? rMax * 0.1 : 0;
  const span = Math.max(0, rMax - minRadius);
  const step = octaves ? (span / octaves) : 0;
  return {rMax, step, octaves, minRadius, minFreq: minDisplayFreq(), maxFreq: maxDisplayFreq()};
}
function baseAngleFromFifthIndex(i){ return ANG0 + 2*Math.PI*(i%12)/12; }
function angleForMidiAbs(m){ const pc=((m%12)+12)%12; const idx=FIFTH_INDEX[pc]; return baseAngleFromFifthIndex(idx) + diskAngle; } // 物理用
function angleForMidiDraw(m, drawRot){ const pc=((m%12)+12)%12; const idx=FIFTH_INDEX[pc]; return baseAngleFromFifthIndex(idx) + drawRot; } // 描画用
function radiusFromFreq(f, rMax, step, minRadius = 0){
  const octaves = activeOctaveCount();
  const oc = Math.log2(f / minDisplayFreq());
  const ocClamped = Math.max(0, Math.min(octaves, oc));
  const r = rMax - step*ocClamped;
  return Math.max(minRadius, Math.min(rMax, r));
}
function polarToXY(cx,cy,r,th){ return { x: cx + r*Math.cos(th), y: cy - r*Math.sin(th) }; }
function shortestDelta(a,b){ let d=b-a; while(d> Math.PI) d-=2*Math.PI; while(d<=-Math.PI) d+=2*Math.PI; return d; }
// ステータス表示の更新を一元化
function updateMIDIStat(text){ midiStat.textContent = 'MIDI: ' + text; }

/* 表示系 */
let linkAlpha = parseInt(lineASlider.value,10)/100; lineAVal.textContent=`${Math.round(linkAlpha*100)}%`;
lineASlider.oninput = ()=>{ linkAlpha = parseInt(lineASlider.value,10)/100; lineAVal.textContent=`${Math.round(linkAlpha*100)}%`; saveSettings(); };

// 直線表示の不透明度をスライダーで制御
let straightLinkAlpha = parseInt(straightLineASlider.value,10)/100; straightLineAVal.textContent=`${Math.round(straightLinkAlpha*100)}%`;
straightLineASlider.oninput = ()=>{
  straightLinkAlpha = parseInt(straightLineASlider.value,10)/100;
  straightLineAVal.textContent = `${Math.round(straightLinkAlpha*100)}%`;
  saveSettings();
};

// ガイド線の可視性調整
let noteGuideAlpha = parseInt(noteGuideASlider.value,10)/100; noteGuideAVal.textContent=`${Math.round(noteGuideAlpha*100)}%`;
noteGuideASlider.oninput = ()=>{
  noteGuideAlpha = parseInt(noteGuideASlider.value,10)/100;
  noteGuideAVal.textContent = `${Math.round(noteGuideAlpha*100)}%`;
  saveSettings();
};

// ガイド番号の不透明度
let noteGuideLabelAlpha = parseInt(noteGuideLabelASlider.value,10)/100; noteGuideLabelAVal.textContent=`${Math.round(noteGuideLabelAlpha*100)}%`;
noteGuideLabelASlider.oninput = ()=>{
  noteGuideLabelAlpha = parseInt(noteGuideLabelASlider.value,10)/100;
  noteGuideLabelAVal.textContent = `${Math.round(noteGuideLabelAlpha*100)}%`;
  saveSettings();
};

// 水面表現の濃さを調整
let waterAlpha = parseInt(waterASlider.value,10)/100; waterAVal.textContent=`${Math.round(waterAlpha*100)}%`;
waterASlider.oninput = ()=>{ waterAlpha = parseInt(waterASlider.value,10)/100; waterAVal.textContent=`${Math.round(waterAlpha*100)}%`; saveSettings(); };

// 移動ド番号の表示強度
let movNumAlpha = parseInt(movNumASlider.value,10)/100; movNumAVal.textContent=`${Math.round(movNumAlpha*100)}%`;
movNumASlider.oninput = ()=>{ movNumAlpha = parseInt(movNumASlider.value,10)/100; movNumAVal.textContent=`${Math.round(movNumAlpha*100)}%`; saveSettings(); };

// 移動ド番号の文字サイズ
let movNumSizePx = parseInt(movNumSizeSlider.value,10); movNumSizeVal.textContent=`${movNumSizePx}px`;
movNumSizeSlider.oninput = ()=>{ movNumSizePx = parseInt(movNumSizeSlider.value,10); movNumSizeVal.textContent=`${movNumSizePx}px`; saveSettings(); };

// ラベル文字サイズ
let labelFontPx = parseInt(labelSizeSlider.value,10); labelSizeVal.textContent=`${labelFontPx}px`;
labelSizeSlider.oninput = ()=>{ labelFontPx = parseInt(labelSizeSlider.value,10); labelSizeVal.textContent=`${labelFontPx}px`; saveSettings(); };

// ラベル背景の透明度
let labelBgAlpha = parseInt(labelBGSlider.value,10)/100; labelBGVal.textContent=`${Math.round(labelBgAlpha*100)}%`;
labelBGSlider.oninput = ()=>{ labelBgAlpha = parseInt(labelBGSlider.value,10)/100; labelBGVal.textContent=`${Math.round(labelBgAlpha*100)}%`; saveSettings(); };

// ラベルテキストの透明度
let labelTextAlpha = parseInt(labelAlphaSlider.value,10)/100; labelAlphaVal.textContent=`${Math.round(labelTextAlpha*100)}%`;
labelAlphaSlider.oninput = ()=>{
  labelTextAlpha = parseInt(labelAlphaSlider.value,10)/100;
  labelAlphaVal.textContent = `${Math.round(labelTextAlpha*100)}%`;
  saveSettings();
};

/* ===== Global state ===== */
let worldRot = 0;          // 描画用回転（anchorにより決定）
let diskAngle = 0, diskOmega = 0;
let diskMass = Math.pow(10, parseFloat(massSlider.value));
let excludeMode = excludeSel.value;
let midiDataRaw = null; // 未移調のMIDIデータ
let midiData = null;    // 現在の移調を反映したデータ {ppq, tempos:[...], notes:[...], lengthSec, onsets, onsetTicks}
let trainer = null;
let player = null;
let seekMuting = false;
let seekWasRunning = false;

function applySeekMuteState(){
  if(synth && typeof synth.setMuted === 'function') synth.setMuted(seekMuting);
}
excludeSel.onchange = ()=>{ excludeMode = excludeSel.value; saveSettings(); };

// UIを隠したフルスクリーン表示中はスクロールできなくてもよいので、
// ディスク（anchor=disk時は水面）をドラッグで回転させる操作を用意する。
const dragRot = {
  active: false,
  startAngle: 0,
  startDiskAngle: 0,
  anchor: 'water'
};
function clientAngle(ev){
  const rect = cv.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const x = (ev.clientX != null) ? ev.clientX : (ev.touches && ev.touches[0] && ev.touches[0].clientX);
  const y = (ev.clientY != null) ? ev.clientY : (ev.touches && ev.touches[0] && ev.touches[0].clientY);
  if(x == null || y == null) return null;
  const dx = x - cx;
  const dy = cy - y; // 画面座標系をキャンバスの極座標に合わせる
  return Math.atan2(dy, dx);
}
function beginDrag(ev){
  if(ev.button != null && ev.button !== 0) return;
  const ang = clientAngle(ev);
  if(ang == null) return;
  dragRot.active = true;
  dragRot.startAngle = ang;
  dragRot.startDiskAngle = diskAngle;
  dragRot.anchor = anchorSel.value;
  diskOmega = 0; // 手動操作中は慣性をリセット
  if(ev.pointerId != null && cv.setPointerCapture){
    try{ cv.setPointerCapture(ev.pointerId); }catch{}
  }
  ev.preventDefault();
}
function moveDrag(ev){
  if(!dragRot.active) return;
  const ang = clientAngle(ev);
  if(ang == null) return;
  const delta = ang - dragRot.startAngle;
  const dir = (dragRot.anchor === 'disk') ? -1 : 1;
  diskAngle = dragRot.startDiskAngle + dir * delta;
  diskOmega = 0;
  ev.preventDefault();
}
function endDrag(ev){
  if(!dragRot.active) return;
  dragRot.active = false;
  if(ev && ev.pointerId != null && cv.releasePointerCapture){
    try{ cv.releasePointerCapture(ev.pointerId); }catch{}
  }
}
cv.addEventListener('pointerdown', beginDrag, {passive:false});
cv.addEventListener('pointermove', moveDrag, {passive:false});
cv.addEventListener('pointerup', endDrag, {passive:false});
cv.addEventListener('pointercancel', endDrag, {passive:false});
cv.addEventListener('pointerleave', endDrag, {passive:false});

/* ωmax（log10軸） */
function fmtOmega(v){
  if (v >= 10) return v.toFixed(0);
  if (v >= 1)  return v.toFixed(2);
  if (v >= 0.1) return v.toFixed(3);
  return v.toFixed(4);
}
let omegaMaxExp = parseFloat(omegaMaxSlider.value);
let omegaMax = Math.pow(10, omegaMaxExp);
function applyOmegaMaxFromSlider(){
  omegaMaxExp = parseFloat(omegaMaxSlider.value);
  omegaMax = Math.pow(10, omegaMaxExp);
  omegaMaxVal.textContent = `${fmtOmega(omegaMax)} rad/s`;
}
applyOmegaMaxFromSlider();
omegaMaxSlider.oninput = ()=>{
  applyOmegaMaxFromSlider();
  // UI操作に追従して設定を永続化
  saveSettings();
};

/* MIDI transpose */
function formatTransposeValue(v){
  const sign = v >= 0 ? '+' : '';
  const suffix = lang === 'ja' ? '半音' : 'st';
  return `${sign}${v} ${suffix}`;
}
function updateTransposeDisplay(){
  transposeVal.textContent = formatTransposeValue(midiTranspose);
}
function formatTime(sec){
  const clamped = Math.max(0, Math.floor(Number.isFinite(sec) ? sec : 0));
  const m = Math.floor(clamped / 60);
  const s = clamped % 60;
  return `${m}:${String(s).padStart(2, '0')}`;
}
function updateSeekUI(pos = 0, total = null){
  const totalSec = (total != null) ? Math.max(0, total) : Math.max(0, midiData?.lengthSec || 0);
  const posSec = Math.max(0, Math.min(pos || 0, totalSec));
  const frac = totalSec ? Math.min(1, posSec / totalSec) : 0;
  seekSlider.value = (frac * 1000).toFixed(2);
  seekSlider.disabled = !totalSec;
  seekTime.textContent = `${formatTime(posSec)} / ${formatTime(totalSec)}`;
}
updateSeekUI();
function applyTransposeSetting({shouldSave = true, preservePlayback = false} = {}){
  const raw = parseInt(transposeSlider.value, 10);
  const clamped = Math.max(-6, Math.min(6, Number.isNaN(raw) ? 0 : raw));
  midiTranspose = clamped;
  if(String(clamped) !== transposeSlider.value) transposeSlider.value = String(clamped);
  updateTransposeDisplay();
  if(shouldSave) saveSettings();
  rebuildMidiView({preservePlayback});
}
updateTransposeDisplay();
transposeSlider.addEventListener('input', ()=> applyTransposeSetting({preservePlayback:true}));

/* ダンピング（比例）。スライダー値 = p%/s */
let dampPerSec = 0.99; // 初期（99%/s）
function fmtPct(p){ return Math.round(p).toString(); }
function updateDampFromSlider(){
  const raw = parseFloat(dampSlider.value);
  const p = Number.isNaN(raw) ? 0 : Math.max(0, Math.min(99, raw));
  dampPerSec = p / 100;                                   // 0.00〜0.99
  dampVal.textContent = `${fmtPct(p)}%/s`;
}
updateDampFromSlider();
// スライダーを動かすたびに内部状態と保存処理を更新
dampSlider.oninput = ()=>{ updateDampFromSlider(); saveSettings(); };

let snapZeroAlpha = snapAlphaCheckbox.checked;
// α=0時に角速度を強制的にゼロにするかどうかを反映
snapAlphaCheckbox.onchange = ()=>{ snapZeroAlpha = snapAlphaCheckbox.checked; saveSettings(); };

/* UI opacity / mass */
// UI全体の透明度をスライダーから算出し、最低値を0.1までに制限
function applyUIOpacity(){ const a=Math.max(0.1, Math.min(1, parseInt(uiopSlider.value,10)/100)); uiPanel.style.opacity=a; uiopVal.textContent=`${Math.round(a*100)}%`; }
applyUIOpacity(); uiopSlider.oninput = ()=>{ applyUIOpacity(); saveSettings(); };
// 対数スライダーで受け取った値を指数化してディスク質量へ変換
function updateMass(){ const lg=parseFloat(massSlider.value); diskMass=Math.pow(10,lg); massVal.textContent=`M=${diskMass.toFixed(2)}`; }
updateMass(); massSlider.oninput = ()=>{ updateMass(); saveSettings(); };

const CUT_MAX = 6;
let lowCutOct = Math.max(0, Math.min(CUT_MAX, parseInt(lowCutSlider.value,10) || 0));
let highCutOct = Math.max(0, Math.min(CUT_MAX, parseInt(highCutSlider.value,10) || 0));
function activeOctaveCount(){ return Math.max(1, OCTAVES - lowCutOct - highCutOct); }
function minDisplayFreq(){ return F_LOW * Math.pow(2, lowCutOct); }
function maxDisplayFreq(){ return F_LOW * Math.pow(2, lowCutOct + activeOctaveCount()); }
function formatCutValue(v){ return lang==='ja' ? `${v}オクターブ` : `${v} oct`; }
function updateCutDisplays(){
  lowCutVal.textContent = formatCutValue(lowCutOct);
  highCutVal.textContent = formatCutValue(highCutOct);
}
function clampLowCut(value){
  const maxAllowed = Math.min(CUT_MAX, Math.max(0, OCTAVES - 1 - highCutOct));
  return Math.max(0, Math.min(maxAllowed, value));
}
function clampHighCut(value){
  const maxAllowed = Math.min(CUT_MAX, Math.max(0, OCTAVES - 1 - lowCutOct));
  return Math.max(0, Math.min(maxAllowed, value));
}
function applyLowCut(value, shouldSave = true){
  const clamped = clampLowCut(Number.isNaN(value) ? 0 : value);
  // スライダー表示と内部状態をクランプ後の値に揃える
  if(String(clamped) !== lowCutSlider.value) lowCutSlider.value = String(clamped);
  if(lowCutOct !== clamped){
    lowCutOct = clamped;
    if(shouldSave) saveSettings();
  }else if(shouldSave){
    saveSettings();
  }
  updateCutDisplays();
}
function applyHighCut(value, shouldSave = true){
  const clamped = clampHighCut(Number.isNaN(value) ? 0 : value);
  // 無駄な保存処理を避けるため、変化があったときだけ保存
  if(String(clamped) !== highCutSlider.value) highCutSlider.value = String(clamped);
  if(highCutOct !== clamped){
    highCutOct = clamped;
    if(shouldSave) saveSettings();
  }else if(shouldSave){
    saveSettings();
  }
  updateCutDisplays();
}
updateCutDisplays();
lowCutSlider.addEventListener('input', ()=>{
  const value = parseInt(lowCutSlider.value,10);
  applyLowCut(Number.isNaN(value) ? 0 : value);
});
highCutSlider.addEventListener('input', ()=>{
  const value = parseInt(highCutSlider.value,10);
  applyHighCut(Number.isNaN(value) ? 0 : value);
});

DEFAULT_SETTINGS = collectSettingsFromUI();
if(resetBtn){
  resetBtn.addEventListener('click', ()=>{
    // ページ初期化直後の設定スナップショットを基準値として利用
    const defaults = DEFAULT_SETTINGS || collectSettingsFromUI();
    const currentLang = lang;
    // 言語選択だけは保持したまま他のパラメータをリセット
    applySettings(defaults, {force:true});
    lang = currentLang;
    applyUIScale();
    applyI18N();
    midiTranspose = 0;
    transposeSlider.value = '0';
    applyTransposeSetting({preservePlayback:false});
    snapZeroAlpha = snapAlphaCheckbox.checked;
    updateDampFromSlider();
    updateFileOpUI();
    saveSettings();
    connectMIDIAccordingToUI();
  });
}

/* ===== Note state ===== */
// liveNotes と fileNotes は後段の描画・物理計算で参照する入力ノート集合を保持する。
// どちらも MIDI ノート番号をキー、ベロシティを値とした Map とし、
// 実行時に随時追加・削除される動的な状態を扱う。
const liveNotes = new Map();     // ハードMIDI入力の現在押下
const fileNotes = new Map();     // 再生中のMIDIファイル由来

// NOTE_GUIDE_MARKS は水面に描画する目盛りラベルの一覧。
// degree 方向と表示文字列を組み合わせて定義し、
// drawNoteGuides 内で極座標位置決定に用いる。
const NOTE_GUIDE_MARKS = [
  {deg: 30, label: '+1'},
  {deg: 60, label: '+2'},
  {deg: 90, label: '+3'},
  {deg: 120, label: '+4'},
  {deg: 150, label: '+5'},
  {deg: 180, label: 'T'},
  {deg: -30, label: '-1'},
  {deg: -60, label: '-2'},
  {deg: -90, label: '-3'},
  {deg: -120, label: '-4'},
  {deg: -150, label: '-5'}
];

// NOTE_GUIDE_BASE_COLORS は 1 周分のグラデーション定義。
// offset を 0.0-1.0 の範囲で解釈し、各区間を線形補間することで
// 現在角度に応じた色を生成する。
const NOTE_GUIDE_BASE_COLORS = [
  {offset: 0.00, rgba: [255, 255, 255, 0]},  // south -> transparent
  {offset: 0.25, rgba: [224, 64, 48, 1]},    // west -> red
  {offset: 0.50, rgba: [0, 0, 0, 1]},        // north -> black
  {offset: 0.75, rgba: [64, 200, 120, 1]},   // east -> green
  {offset: 1.00, rgba: [255, 255, 255, 0]}   // wrap back to south
];

// 与えられた offset（周回位置）から NOTE_GUIDE_BASE_COLORS を補間し、
// 実際に使用する RGBA 値を算出する。
function interpolateNoteGuideColor(offset){
  const normalized = ((offset % 1) + 1) % 1;
  const stops = NOTE_GUIDE_BASE_COLORS;
  if(normalized === 0){
    const [r,g,b,a] = stops[0].rgba;
    return {r, g, b, a};
  }
  for(let i=0; i<stops.length-1; i++){
    const current = stops[i];
    const next = stops[i+1];
    if(normalized >= current.offset && normalized <= next.offset){
      const span = next.offset - current.offset;
      const t = span === 0 ? 0 : (normalized - current.offset) / span;
      const r = Math.round(current.rgba[0] + (next.rgba[0] - current.rgba[0]) * t);
      const g = Math.round(current.rgba[1] + (next.rgba[1] - current.rgba[1]) * t);
      const b = Math.round(current.rgba[2] + (next.rgba[2] - current.rgba[2]) * t);
      const a = current.rgba[3] + (next.rgba[3] - current.rgba[3]) * t;
      return {r, g, b, a};
    }
  }
  const [r,g,b,a] = stops[stops.length-1].rgba;
  return {r, g, b, a};
}

// RGBA オブジェクトを CSS 互換の rgba() 文字列へ変換する小さなユーティリティ。
function rgbaToCss({r,g,b,a}){
  const alpha = Math.max(0, Math.min(1, a));
  const rounded = Math.round(alpha * 1000) / 1000;
  return `rgba(${r},${g},${b},${rounded})`;
}

// NOTE_GUIDE_BASE_COLORS と interpolateNoteGuideColor を組み合わせて
// 指定 offset に対応する CSS 色文字列を得るヘルパー。
function noteGuideColorForOffset(offset){
  return rgbaToCss(interpolateNoteGuideColor(offset));
}

const NOTE_GUIDE_SEGMENT_COUNT = 12;
const NOTE_GUIDE_SEGMENT_SPAN = 1 / NOTE_GUIDE_SEGMENT_COUNT;
const NOTE_GUIDE_SEGMENT_HALF_SPAN = NOTE_GUIDE_SEGMENT_SPAN / 2;
// NOTE_GUIDE_SEGMENTS はグラデーションをセグメント単位に事前分割した配列。
// 描画ループで毎回補間するコストを抑えるため、中心 offset ごとに色を保持する。
const NOTE_GUIDE_SEGMENTS = Array.from({length: NOTE_GUIDE_SEGMENT_COUNT}, (_, i)=>{
  const centerOffset = i / NOTE_GUIDE_SEGMENT_COUNT;
  const startOffset = centerOffset - NOTE_GUIDE_SEGMENT_HALF_SPAN;
  const endOffset = centerOffset + NOTE_GUIDE_SEGMENT_HALF_SPAN;
  let rgba = interpolateNoteGuideColor(centerOffset);
  if(i === 0){
    rgba = {r: 255, g: 255, b: 255, a: 0};
  }
  return {startOffset, endOffset, rgba, css: rgbaToCss(rgba)};
});

// drawNoteGuides は音の位置に応じて水面の扇形やラベルを描画する。
// notePositions: 描画対象となる polar 座標情報を含む配列。
// cx/cy: キャンバス中心、diskRadius: 最大半径。
  function drawNoteGuides(notePositions, cx, cy, diskRadius){
    // ガイドを描く必要が無い状況 (データが無い、透明度 0) は即座に打ち切る。
    if(!notePositions.length || (noteGuideAlpha <= 0 && noteGuideLabelAlpha <= 0)) return;
    const fontPx = Math.round(12 * devicePixelRatio);

    if(noteGuideAlpha > 0){
      ctx.save();
      ctx.globalAlpha = noteGuideAlpha;
      const fullTurn = Math.PI * 2;
      // rAbs が有効なノートだけを取り出し、遠い順に並べて半径の大小関係を把握する。
      const sortedByRadius = [...notePositions]
        .filter(pos=>Number.isFinite(pos.rAbs) && pos.rAbs > 0)
        .sort((a,b)=> b.rAbs - a.rAbs);
      const innerRadiusByMidi = new Map();
      // 各ノートについて、次に近いノートの半径を「内側の境界」として記録する。
      // 次のノートが存在しない場合はディスクを 12 分割した幅だけ内側へ縮める。
      for(let i=0; i<sortedByRadius.length; i++){
        const current = sortedByRadius[i];
        const next = sortedByRadius[i+1];
        let inner = next ? next.rAbs : current.rAbs - (diskRadius / 12);
        if(!Number.isFinite(inner)) inner = 0;
        innerRadiusByMidi.set(current.midi, Math.max(0, inner));
      }

      // ノートごとに外周半径と求めた内周半径でドーナツ状の扇形を描画する。
      for(const pos of notePositions){
        const outerRadius = pos.rAbs;
        if(!Number.isFinite(outerRadius) || outerRadius <= 0) continue;
        const rawInner = innerRadiusByMidi.get(pos.midi);
        const innerRadius = rawInner==null ? 0 : Math.max(0, Math.min(outerRadius, rawInner));
        if(innerRadius >= outerRadius && innerRadius !== 0) continue;

        // NOTE_GUIDE_SEGMENTS で事前計算した色グラデーションを扇形ごとに適用する。
        for(let i=0; i<NOTE_GUIDE_SEGMENT_COUNT; i++){
          const segment = NOTE_GUIDE_SEGMENTS[i];
          const {rgba, css, startOffset, endOffset} = segment;
          if(rgba.a <= 0) continue;
          const startAngle = -pos.theta + endOffset * fullTurn;
          const endAngle = -pos.theta + startOffset * fullTurn;

          // 外周から内周に向かってパスを閉じ、水面に重ねる扇状の塗りを行う。
          ctx.beginPath();
          ctx.arc(cx, cy, outerRadius, startAngle, endAngle, true);
          if(innerRadius > 0){
            ctx.arc(cx, cy, innerRadius, endAngle, startAngle, false);
          }else{
            ctx.lineTo(cx, cy);
          }
          ctx.closePath();
          ctx.fillStyle = css;
          ctx.fill();
        }
      }

      ctx.restore();
    }

    if(noteGuideLabelAlpha > 0){
      ctx.save();
      ctx.globalAlpha = noteGuideLabelAlpha;
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${fontPx}px system-ui`;

      // それぞれのノートの極座標をデカルト座標に変換し、ラベル文字列を配置する。
      for(const pos of notePositions){
        const radius = pos.rAbs;
        if(!Number.isFinite(radius) || radius <= 0) continue;

        // NOTE_GUIDE_MARKS に定義されたマーク (度数や文字) を回転角度分だけ配置。
        for(const mark of NOTE_GUIDE_MARKS){
          const angle = pos.theta + mark.deg * Math.PI / 180;
          const {x, y} = polarToXY(cx, cy, radius, angle);
          ctx.fillText(mark.label, x, y);
        }
      }

      ctx.restore();
    }
  }

/* ===== Drawing ===== */
function drawNotes(points, drawRot){
  if(!points.length) return;
  const {rMax, step, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq}=ringParams(); const cx=cv.width/2, cy=cv.height/2;

  const inRange = [];
  const belowRange = [];
  const aboveRange = [];
  // 画面内に入る音・低すぎる音・高すぎる音を分類してエッジケースの描画を安定させる
  for(const p of points){
    const f = midiToHz(p.midi);
    if(f < displayMinFreq){
      belowRange.push({midi:p.midi, vel:p.vel, f});
    }else if(f > displayMaxFreq){
      aboveRange.push({midi:p.midi, vel:p.vel, f});
    }else{
      inRange.push({midi:p.midi, vel:p.vel, f});
    }
  }
  if(!inRange.length && !belowRange.length && !aboveRange.length) return;

  let low=null, high=null;
  const allPoints = [...inRange, ...belowRange, ...aboveRange];
  for(const p of allPoints){
    if(!low || p.f<low.f) low=p;
    if(!high|| p.f>high.f) high=p;
  }
  function ring(p, color, label, position = 'top'){
    // MIDIノートを極座標に変換して円形のマーカーとラベルを描く
    const freq = (p && p.f!=null) ? p.f : midiToHz(p.midi);
    const th=angleForMidiDraw(p.midi, drawRot), r=radiusFromFreq(freq,rMax,step,minRadius), {x,y}=polarToXY(cx,cy,r,th);
    ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=3; ctx.arc(x,y,16+10*p.vel*devicePixelRatio,0,2*Math.PI); ctx.stroke();
    ctx.fillStyle=color; ctx.font=`${11*devicePixelRatio}px system-ui`; ctx.textAlign='center';
    const labelOffset = 22 * devicePixelRatio;
    if(position === 'bottom'){
      ctx.textBaseline='top';
      ctx.fillText(label, x, y + labelOffset);
    }else{
      ctx.textBaseline='bottom';
      ctx.fillText(label, x, y - labelOffset);
    }
  }
  function labelOnly(p, label, position = 'top', color = 'rgba(220,220,220,0.9)'){
    const freq = (p && p.f!=null) ? p.f : midiToHz(p.midi);
    const th=angleForMidiDraw(p.midi, drawRot), r=radiusFromFreq(freq,rMax,step,minRadius), {x,y}=polarToXY(cx,cy,r,th);
    ctx.fillStyle=color; ctx.font=`${11*devicePixelRatio}px system-ui`; ctx.textAlign='center';
    const labelOffset = 18 * devicePixelRatio;
    if(position === 'bottom'){
      ctx.textBaseline='top';
      ctx.fillText(label, x, y + labelOffset);
    }else{
      ctx.textBaseline='bottom';
      ctx.fillText(label, x, y - labelOffset);
    }
  }
  if(low)  ring(low,'rgba(0,200,255,0.95)','LOW','bottom');
  if(high) ring(high,'rgba(255,160,0,0.95)','HIGH','top');

  if(inRange.length){
    const strongestByMidi = new Map();
    for(const p of inRange){
      const current = strongestByMidi.get(p.midi);
      if(!current || p.vel > current.vel){
        strongestByMidi.set(p.midi, p);
      }
    }
    const ranked = Array.from(strongestByMidi.values())
      .sort((a,b)=> a.f - b.f);
    for(let i=0;i<ranked.length;i++){
      const p = ranked[i];
      if((low && p.midi === low.midi) || (high && p.midi === high.midi)) continue;
      labelOnly(p, String(i+1), 'top');
    }
  }

  const toPosition = (p)=>{
    const theta = angleForMidiDraw(p.midi, drawRot);
    const rAbs = radiusFromFreq(p.f, rMax, step, minRadius);
    const {x, y} = polarToXY(cx, cy, rAbs, theta);
    return {...p, theta, rAbs, x, y};
  };

  const notePositions = inRange.map(toPosition);
  if(notePositions.length) drawNoteGuides(notePositions, cx, cy, rMax);
  const straightLinePositions = allPoints.map(toPosition);

  if(straightLinePositions.length>=2 && straightLinkAlpha>0){
    ctx.save();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = `rgba(255,128,0,${straightLinkAlpha})`;
    for(let i=0;i<straightLinePositions.length-1;i++){
      const a = straightLinePositions[i];
      for(let j=i+1;j<straightLinePositions.length;j++){
        const b = straightLinePositions[j];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  for(const p of notePositions){
    const radius=4+12*p.vel, alpha=0.3+0.6*p.vel;
    ctx.beginPath(); ctx.fillStyle=`rgba(255,255,255,${alpha})`; ctx.arc(p.x,p.y,radius,0,2*Math.PI); ctx.fill();
  }

  if(inRange.length>=2){
    const xs = inRange.map(p=>({m:p.midi,f:p.f})).sort((a,b)=>a.f-b.f);
    ctx.lineWidth=2; ctx.strokeStyle=`rgba(255,255,255,${linkAlpha})`;
    for(let i=0;i<xs.length-1;i++){
      const m0=xs[i].m,f0=xs[i].f,m1=xs[i+1].m,f1=xs[i+1].f;
      const r0=radiusFromFreq(f0,rMax,step,minRadius), th0=angleForMidiDraw(m0, drawRot);
      const r1=radiusFromFreq(f1,rMax,step,minRadius), th1=angleForMidiDraw(m1, drawRot);
      const dth = shortestDelta(th0, th1);
      const steps=48; ctx.beginPath();
      for(let s=0;s<=steps;s++){ const t=s/steps, r=r0+t*(r1-r0), th=th0+t*dth; const {x,y}=polarToXY(cx,cy,r,th); if(s===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.stroke();
    }
  }

  if(belowRange.length || aboveRange.length){
    const highMarkerRadius = Math.max(minRadius, rMax * 0.1);
    const drawOutOfRange = (list, radius, color)=>{
      for(const p of list){
        const theta = angleForMidiDraw(p.midi, drawRot);
        const {x,y}=polarToXY(cx,cy,radius,theta);
        const markerRadius=4+12*p.vel;
        ctx.beginPath(); ctx.fillStyle=color; ctx.arc(x,y,markerRadius,0,2*Math.PI); ctx.fill();
      }
    };
    if(belowRange.length){
      drawOutOfRange(belowRange, rMax, 'rgba(255,120,120,0.85)');
    }
    if(aboveRange.length){
      drawOutOfRange(aboveRange, highMarkerRadius, 'rgba(120,180,255,0.85)');
    }
  }
}

/* ターゲット描画（トレーナー） */
// drawTargetNotes はトレーナーモードで指定したターゲットノートを視覚化する。
// MIDI 番号を受け取り、表示範囲内でリング上にハイライトを描画する。
function drawTargetNotes(targets, drawRot){
  if(!targets || !targets.length) return;
  const {rMax, step, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq}=ringParams(); const cx=cv.width/2, cy=cv.height/2;
  for(const midi of targets){
    const freq = midiToHz(midi);
    if(freq < displayMinFreq || freq > displayMaxFreq) continue;
    const th=angleForMidiDraw(midi, drawRot), r=radiusFromFreq(freq,rMax,step,minRadius), {x,y}=polarToXY(cx,cy,r,th);
    ctx.beginPath(); ctx.strokeStyle='rgba(100,255,120,0.95)'; ctx.lineWidth=4; ctx.arc(x,y,15*devicePixelRatio,0,2*Math.PI); ctx.stroke();
    ctx.fillStyle='rgba(100,255,120,0.95)'; ctx.font=`${12*devicePixelRatio}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.fillText('TARGET', x, y+22*devicePixelRatio);
  }
}

/* 移動ド数字（水面回転と同期） */
// drawMovableDoNumbers は移動ド（メロディック・ソルフェージュ）の数字を描く。
// 回転角 halfCenter に追従しながらリング内側に等間隔で表示する。
function drawMovableDoNumbers(halfCenter, rMax, cx, cy){
  const r = rMax * 0.78;
  const fontPx = Math.round(Math.max(12, movNumSizePx) * devicePixelRatio);
  const pf=ctx.font, pa=ctx.globalAlpha, ps=ctx.fillStyle, pal=ctx.textAlign, pb=ctx.textBaseline;
  // 現在のフォント設定を保存しつつ移動ドの番号を書き込む
  ctx.font = `${fontPx}px system-ui`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.globalAlpha = movNumAlpha;
  ctx.fillStyle = 'rgba(255,220,70,1)';
  const seq = ['7','3','6','2','5','1','4','-7','-3','-6','-2','+4'];
  const start = halfCenter - Math.PI/2; // 水面右端
  for(let i=0;i<12;i++){
    const theta = start + i*(Math.PI/6);
    const x = cx + r*Math.cos(theta), y = cy + r*Math.sin(theta);
    ctx.fillText(seq[i], x, y);
  }
  ctx.font=pf; ctx.globalAlpha=pa; ctx.fillStyle=ps; ctx.textAlign=pal; ctx.textBaseline=pb;
}

/* ===== Main draw loop ===== */
let prevT=null;
// draw はキャンバス全体のメイン描画ループ。
// 物理演算の結果を反映しながら、水面・ノート・補助情報を毎フレーム再描画する。
function draw(){
  const w=cv.width, h=cv.height, cx=w/2, cy=h/2;
  const {rMax, step, octaves, minRadius, minFreq: displayMinFreq, maxFreq: displayMaxFreq} = ringParams();
  const now = performance.now()/1000;
  // 前フレームとの経過時間を計算し、極端な変動はクランプ
  const dt = prevT? Math.max(1/240, Math.min(0.25, now-prevT)) : 1/60;
  prevT = now;

  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#0d1016';
  ctx.fillRect(0,0,w,h);

  // ディスク本体の塗りつぶし（フラットカラー）
  const diskRadius = rMax + 8;
  ctx.beginPath();
  ctx.arc(cx, cy, diskRadius, 0, 2*Math.PI);
  ctx.fillStyle = 'rgba(24,28,36,0.95)';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(220,235,255,0.18)';
  ctx.stroke();

  // 物理に使う入力
  // - 再生: ファイル由来 + ライブ入力
  // - トレーナ: ライブ入力のみ（ターゲットは描画だけ）
  const physicsPoints = (fileOp.value==='play')
    ? [...Array.from(liveNotes, ([m,v])=>({midi:m, vel:v})),
       ...Array.from(fileNotes, ([m,v])=>({midi:m, vel:v}))]
    : [...Array.from(liveNotes, ([m,v])=>({midi:m, vel:v}))];

  const hasPhysInput = physicsPoints.length>0;
  // 物理計算に使えるノートがあるかどうかを示すフラグ

  // 物理
  const tau = hasPhysInput ? torqueFromPoints(physicsPoints, GRAV_ABS, rMax, step, minRadius, displayMinFreq, displayMaxFreq, excludeMode) : 0;
  // トルクを質量で割って角加速度を求める
  const alpha = tau / Math.max(1e-6, diskMass);
  if (snapZeroAlpha && Math.abs(alpha) < 1e-6){
    diskOmega = 0;
  }else{
    diskOmega += alpha * dt;
  }

  // ダンピング：1秒あたり (1 - p%)^dt
  const k = Math.max(0, Math.min(1, 1 - dampPerSec));
  diskOmega *= Math.pow(k, dt);

  // 最大回転速度（対数スライダで設定）
  if(diskOmega > omegaMax) diskOmega = omegaMax;
  else if(diskOmega < -omegaMax) diskOmega = -omegaMax;

  diskAngle += diskOmega * dt;

  // 表示回転と水面中心
  const anchor = anchorSel.value;                 // 'water' | 'disk'
  const drawRot = (anchor==='water') ? diskAngle : 0;
  const halfCenter = (anchor==='water') ? GRAV_ABS : (GRAV_ABS + diskAngle);
  worldRot = drawRot;

  info.textContent = `disk | τ=${tau.toFixed(3)} α=${alpha.toFixed(3)} ω=${diskOmega.toFixed(3)} rad/s`;

  // 放射線
  ctx.save(); ctx.translate(cx,cy);
  // 完全5度圏に基づく放射線を一度に描き、A音だけを強調表示
  const highlightAIndex = FIFTH_INDEX[9];
  for(let k2=0;k2<12;k2++){
    const ang = baseAngleFromFifthIndex(k2) - drawRot;
    const isA = (k2 === highlightAIndex);
    ctx.beginPath();
    ctx.strokeStyle = isA ? 'rgba(0,140,140,0.95)' : 'rgba(255,255,255,0.18)';
    ctx.lineWidth = isA ? 3 : 1.5;
    ctx.moveTo(0,0); ctx.lineTo((rMax+6)*Math.cos(ang),(rMax+6)*Math.sin(ang));
    ctx.stroke();
  }
  ctx.restore();

  // 同心円
  ctx.strokeStyle='rgba(255,255,255,0.22)';
  ctx.lineWidth = 1.5;
  for(let i=0;i<=octaves;i++){
    const rRaw = rMax - i*step;
    const radius = Math.max(minRadius, Math.min(rMax, rRaw));
    if(radius <= 0) continue; // iOS Safari throws if radius is 0 or negative
    // 半径が負にならないように安全策を入れつつ同心円を描く
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, 2*Math.PI);
    ctx.stroke();
  }
  ctx.lineWidth = 1;

  if(440 >= displayMinFreq && 440 <= displayMaxFreq){
    // 標準ピッチA4=440Hzの位置を特別なリングで示す
    const r440 = radiusFromFreq(440, rMax, step);
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(00,100,100,0.9)';
    ctx.lineWidth = 3;
    ctx.arc(cx, cy, r440, 0, 2*Math.PI);
    ctx.stroke();
  }
  ctx.lineWidth = 1;

  // 外周ラベル
  const fontPx = labelFontPx * devicePixelRatio * 0.95;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font = `${fontPx}px system-ui`;
  for(let k2=0;k2<12;k2++){
    const ang = baseAngleFromFifthIndex(k2) + drawRot;
    const tx = cx + (rMax+18)*Math.cos(ang), ty = cy - (rMax+18)*Math.sin(ang);
    const text = FIFTH_LABELS[k2];
    const pc = FIFTH_ORDER_PCS[k2]; const [r,g,b] = NOTE_BG[pc];
    const m = ctx.measureText(text);
    const padX = 6*devicePixelRatio, padY = 3*devicePixelRatio;
    const wbg = m.width + padX*2, hbg = fontPx + padY*2;
    const vx = tx - cx, vy = ty - cy;
    const safeX = (w/2) - (wbg/2 + 2*devicePixelRatio);
    const safeY = (h/2) - (hbg/2 + 2*devicePixelRatio);
    const sx = Math.min(1, Math.abs(vx)>0 ? safeX/Math.abs(vx) : 1);
    const sy = Math.min(1, Math.abs(vy)>0 ? safeY/Math.abs(vy) : 1);
    const s  = Math.min(sx, sy);
    const tx2 = cx + vx*s, ty2 = cy + vy*s;
    ctx.fillStyle = `rgba(${r},${g},${b},${labelBgAlpha})`;
    ctx.fillRect(tx2 - wbg/2, ty2 - hbg/2, wbg, hbg);
    if(labelTextAlpha>0){
      ctx.fillStyle=`rgba(255,255,255,${labelTextAlpha})`;
      ctx.fillText(text, tx2, ty2);
    }
  }

  // 水面半円＋移動ド数字
  ctx.save(); ctx.translate(cx,cy);
  ctx.beginPath(); ctx.moveTo(0,0);
  ctx.arc(0,0, rMax+6, halfCenter - Math.PI/2, halfCenter + Math.PI/2, false);
  ctx.closePath();
  ctx.fillStyle=`rgba(0,128,255,${waterAlpha})`; ctx.fill();
  ctx.beginPath();
  ctx.arc(0,0, rMax+6, halfCenter - Math.PI/2, halfCenter + Math.PI/2);
  ctx.strokeStyle=`rgba(0,128,255,${waterAlpha})`; ctx.lineWidth=2; ctx.stroke();
  ctx.restore();
  drawMovableDoNumbers(halfCenter, rMax, cx, cy);

  // 入力の可視化
  const livePts = Array.from(liveNotes, ([m,v])=>({midi:m, vel:v}));
  const filePts = Array.from(fileNotes, ([m,v])=>({midi:m, vel:v}));

  if(livePts.length) drawNotes(livePts, drawRot);
  if(filePts.length && fileOp.value==='play') drawNotes(filePts, drawRot);

  // ★トレーナーのターゲット表示（trainer.currentNotesを直接描画）
  if(fileOp.value==='train' && trainer && trainer.active){
    const tn = trainer.currentNotes();
    if(tn && tn.length) drawTargetNotes(tn, drawRot);
  }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

/* ===== Audio ctx & synth ===== */
let audioCtx=null;
// 再利用できるAudioContextを返し、存在しない場合は新規作成
function ensureCtx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000}); return audioCtx; }
class PolySynth{
  constructor(ctx){
    this.ctx=ctx;
    this.masterGain=0.9;
    this.master=ctx.createGain();
    this.master.gain.value=this.masterGain;
    this.master.connect(ctx.destination);
    this.voices=new Map();
    this.muted=false;
  }
  // ノートオン時に2つのオシレータとローパスフィルタを構成し、ADSRでゲインを制御
  noteOn(midi, vel=1, when=null){
    const t = (when!=null)? when : this.ctx.currentTime;
    if(this.voices.has(midi)) this.noteOff(midi, t);
    const f=midiToHz(midi);
    const g=this.ctx.createGain(); g.gain.setValueAtTime(0,t);
    const o1=this.ctx.createOscillator(), o2=this.ctx.createOscillator();
    o1.type='sawtooth'; o2.type='square'; o1.frequency.setValueAtTime(f,t); o2.frequency.setValueAtTime(f,t); o2.detune.setValueAtTime(+3,t);
    const flt=this.ctx.createBiquadFilter(); flt.type='lowpass'; flt.frequency.setValueAtTime(3000,t); flt.Q.setValueAtTime(0.7,t);
    o1.connect(flt); o2.connect(flt); flt.connect(g); g.connect(this.master);
    const A=0.005,D=0.12,S=0.25+0.5*vel,R=0.32,peak=0.8*vel;
    g.gain.linearRampToValueAtTime(peak, t+A);
    g.gain.linearRampToValueAtTime(S*peak, t+A+D);
    o1.start(t); o2.start(t);
    this.voices.set(midi,{o1,o2,g,flt,R});
  }
  // ノートオフ時はターゲット減衰を設定し、一定時間後にノードを破棄
  noteOff(midi, when=null){
    const v=this.voices.get(midi); if(!v) return;
    const t=(when!=null)? when : this.ctx.currentTime, R=v.R;
    v.g.gain.setTargetAtTime(0,t,R/3);
    try { v.o1.stop(t+R+0.05); v.o2.stop(t+R+0.05); } catch(e){}
    setTimeout(()=>{ try{ v.g.disconnect(); v.flt.disconnect(); }catch{} }, (R+0.1)*1000);
    this.voices.delete(midi);
  }
  allNotesOff(){ for(const m of Array.from(this.voices.keys())) this.noteOff(m); }
  setMuted(m){
    this.muted = m;
    const target = m ? 0 : this.masterGain;
    this.master.gain.setTargetAtTime(target, this.ctx.currentTime, 0.01);
  }
}
let synth=null;

/* ===== Web MIDI In（常時） ===== */
let midiAccess=null;
const attachedInputs = new Set();

function hex(n){ return n.toString(16).padStart(2,'0'); }
function logMidi(ev){
  const d = Array.from(ev.data||[]).map(hex).join(' ');
  const name = ev.currentTarget && (ev.currentTarget.name||ev.currentTarget.id||'input');
  midiLast.textContent = `${t('last')} ${name}  ${d}`;
}
function midiMessageHandler(ev){
  logMidi(ev);
  const d=ev.data;
  if(!d || d.length<3) return;
  const st=d[0]&0xf0, note=d[1], vel=d[2];
  // ノートオン/ノートオフを解釈して可視化用のマップに反映
  if(st===0x90){
    if(vel>0){
      liveNotes.set(note, vel/127);
      if(liveMon.checked){ if(!synth) synth=new PolySynth(ensureCtx()); applySeekMuteState(); synth.noteOn(note, vel/127); }
    }else{
      liveNotes.delete(note);
      if(synth) synth.noteOff(note);
    }
  }else if(st===0x80){
    liveNotes.delete(note);
    if(synth) synth.noteOff(note);
  }

  // ★トレーナー：離鍵必須のエッジ検出でステップ進行
  if(fileOp.value==='train' && trainer && trainer.active){
    trainer.considerAdvance(liveNotes);
    updateTrainerUI();
  }
}
async function setupMIDIInputs(){
  if(!isSecureContext && !window.__NATIVE_APP__){ updateMIDIStat(t('midiNeedSecure')); return; }
  if(!('requestMIDIAccess' in navigator)){ updateMIDIStat(t('midiUnsupported')); return; }
  try{
    // Web MIDI APIから利用可能なデバイス一覧を取得
    midiAccess = await navigator.requestMIDIAccess({sysex:false, software:true});
    midiAccess.onstatechange = refreshMIDIInputs;
    await refreshMIDIInputs();
    updateMIDIStat(`${t('midiReady')} (${midiAccess.inputs.size})`);
  }catch(e){
    updateMIDIStat(`${t('midiInitFailed')}: ${e.name||e.message}`);
  }
}
async function refreshMIDIInputs(){
  if(!midiAccess) return;
  midiDev.innerHTML='';
  const inputs = Array.from(midiAccess.inputs.values());
  // 利用可能なMIDI入力をプルダウンに並べる
  for(const inp of inputs){
    const opt=document.createElement('option'); opt.value=inp.id; opt.textContent=inp.name||inp.id; midiDev.appendChild(opt);
  }
  await connectMIDIAccordingToUI();
}
function detachAllInputs(){
  for(const inp of attachedInputs){
    try{ inp.onmidimessage=null; if(inp.removeEventListener) inp.removeEventListener('midimessage', midiMessageHandler); }catch{}
  }
  attachedInputs.clear();
}
async function attachInput(inp){
  try{ await inp.open(); }catch{}
  inp.onmidimessage = midiMessageHandler;
  if(inp.addEventListener) inp.addEventListener('midimessage', midiMessageHandler);
  attachedInputs.add(inp);
}
async function connectMIDIAccordingToUI(){
  if(!midiAccess) return;
  detachAllInputs();
  const inputs = Array.from(midiAccess.inputs.values());
  // 「全入力」がオンなら全ポートを購読し、そうでなければ選択されたデバイスに限定
  if(midiAll.checked || !midiDev.value){
    for(const inp of inputs) await attachInput(inp);
    updateMIDIStat(`${t('midiAllInputsStat')} (${inputs.length})`);
  }else{
    const target = midiAccess.inputs.get(midiDev.value);
    if(target){ await attachInput(target); updateMIDIStat(`${t('midiInputStatPrefix')} ${target.name||target.id}`); }
    else{ updateMIDIStat(t('midiNoDevice')); }
  }
}
midiDev.onchange = ()=>{ connectMIDIAccordingToUI(); saveSettings(); };
midiAll.onchange = ()=>{ connectMIDIAccordingToUI(); saveSettings(); };
// ライブモニタのON/OFFだけは状態を保存するだけで十分
liveMon.onchange = ()=>{ saveSettings(); };

/* ===== 自動開始 ===== */
function autoStart(){
  // AudioContextとMIDI初期化をアプリ起動時にまとめて実施
  ensureCtx();
  setupMIDIInputs().then(connectMIDIAccordingToUI);
}
document.addEventListener('DOMContentLoaded', ()=>{
  // ページ読み込み完了後にUIやMIDIの初期状態を整える
  loadSettings();
  updateUIVisibility();
  updateFileOpUI();
  autoStart();
  loadDefaultMIDI();
});

// iOS: ユーザー操作でAudioContextを復帰
['pointerdown','keydown','touchstart'].forEach(ev=>{
  // iOS Safariは自動再生を禁止するため、初回操作でresumeを試みる
  addEventListener(ev, ()=>{ try{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch{} }, {once:true});
});

/* ===== Disk torque ===== */
function torqueFromPoints(points, gravAbs, rMax, step, minRadius, minFreq, maxFreq, excludeMode){
  let tau = 0;
  for(const p of points){
    const thAbs = angleForMidiAbs(p.midi);  // ディスク絶対角
    const freq = midiToHz(p.midi);
    const r = radiusFromFreq(freq, rMax, step, minRadius);
    const rn = r / rMax;
    const d = shortestDelta(gravAbs, thAbs);
    const absd = Math.abs(d);

    // 除外側だけを±1°だけ広げる
    let excluded;
    if (excludeMode === 'filled'){
      excluded = absd <= (Math.PI/2 + EXCLUDE_PAD_RAD);
    }else{
      excluded = absd >= (Math.PI/2 - EXCLUDE_PAD_RAD);
    }
    if (excluded) continue;

    // ベロシティを0〜1に正規化し、半径と角度差からトルク寄与を計算
    const m = Math.max(0, Math.min(1, p.vel));
    tau += m * rn * Math.sin(d);
  }
  return tau;
}

/* ===== MIDI File loader / parser ===== */
// ファイル関連のメッセージを下部UIに表示
function uiLog(msg){ fileInfo.textContent = msg; }

async function fileToArrayBuffer(file){
  if (file && file.arrayBuffer) {
    // 新しいブラウザではFile#arrayBufferが直接使える
    try { return await file.arrayBuffer(); } catch(e) { /* fallback */ }
  }
  // 上記が失敗した場合はFileReaderで読み込むレガシールートを使用
  return await new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onload = ()=> resolve(fr.result);
    fr.onerror = ()=> reject(fr.error || new Error('FileReader error'));
    fr.readAsArrayBuffer(file);
  });
}
async function handlePickedFile(file){
  try{
    uiLog(`picked: ${file?.name || '(no name)'}  type:${file?.type || 'unknown'}  size:${file?.size || 0}B`);
    if(!file) throw new Error('no file');
    // ファイルをArrayBufferへ変換し、MIDIパーサに渡す準備をする
    const ab = await fileToArrayBuffer(file);
    if(!ab) throw new Error('arrayBuffer empty');

    const parsed = parseMIDI(ab);
    if(!parsed || !parsed.notes) throw new Error('parse failed');
    midiDataRaw = parsed;
    rebuildMidiView();

    const trks = (Array.isArray(midiData.tracks) ? midiData.tracks.length : (midiData.tracks ?? 0));
    uiLog(`OK: ${file.name}  trks:${trks}  ppq:${midiData.ppq}  len:${midiData.lengthSec.toFixed(2)}s  notes:${midiData.notes.length}`);
  }catch(err){
    uiLog(`解析失敗: ${err && err.message ? err.message : err}`);
    console.error(err);
  }
}

async function loadMIDIFromNative(base64, fileName = 'sample.mid'){
  try{
    const binary = atob(base64);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for(let i = 0; i < len; i++){ bytes[i] = binary.charCodeAt(i); }
    const blob = new Blob([bytes], { type: 'audio/midi' });
    let fileLike;
    try{
      fileLike = new File([blob], fileName, { type: blob.type || 'audio/midi', lastModified: Date.now() });
    }catch{
      fileLike = {
        name: fileName,
        type: blob.type || 'audio/midi',
        size: blob.size,
        arrayBuffer: () => blob.arrayBuffer()
      };
    }
    await handlePickedFile(fileLike);
  }catch(err){
    console.warn('failed to load MIDI from native:', err);
  }
}
window.__loadMIDIFromNative = loadMIDIFromNative;

function onFileInput(e){
  const f = e.target && e.target.files && e.target.files[0];
  if(f) handlePickedFile(f);
}
midiFileInput.addEventListener('change', onFileInput);
midiFileInput.addEventListener('input',  onFileInput);

async function loadDefaultMIDI(){
  if(midiData) return;
  if(window.__NATIVE_APP__){
    return;
  }
  try{
    uiLog('loading: sample.mid');
    const res = await fetch('sample.mid');
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const blob = await res.blob();
    const type = blob.type || 'audio/midi';
    const fileName = 'sample.mid';
    let fileLike;
    try{
      fileLike = new File([blob], fileName, { type, lastModified: Date.now() });
    }catch{
      fileLike = {
        name: fileName,
        type,
        size: blob.size,
        arrayBuffer: () => blob.arrayBuffer()
      };
    }
    await handlePickedFile(fileLike);
  }catch(err){
    console.warn('failed to load default MIDI file:', err);
  }
}

// D&D
addEventListener('dragover', e=>{ e.preventDefault(); });
addEventListener('drop', e=>{
  e.preventDefault();
  const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
  if(f && /\.mid(i)?$/i.test(f.name)) handlePickedFile(f);
});

/* ---- Simple Standard MIDI parser (format 0/1) ---- */
function parseMIDI(ab){
  const u8 = new Uint8Array(ab);
  let p = 0;
  function rdU32(){ const v=((u8[p]<<24)|(u8[p+1]<<16)|(u8[p+2]<<8)|u8[p+3])>>>0; p+=4; return v; }
  function rdU16(){ const v=((u8[p]<<8)|u8[p+1])>>>0; p+=2; return v; }
  function rdStr(n){ const s=String.fromCharCode.apply(null, u8.slice(p,p+n)); p+=n; return s; }
  function rdVLQ(){ let v=0; let b; do{ b=u8[p++]; v=(v<<7)|(b&0x7f); }while(b&0x80); return v; }

  function expect(tag){ const s=rdStr(4); if(s!==tag) throw new Error(`expect ${tag}, got ${s}`); }
  expect('MThd'); const len=rdU32(); const pHdr=p; const format=rdU16(); const ntrks=rdU16(); const division=rdU16(); p=pHdr+len;

  if(division & 0x8000) throw new Error('SMPTE time not supported');
  const ppq = division;

  const tracks=[];
  for(let t=0;t<ntrks;t++){
    expect('MTrk'); const tlen=rdU32(); const end=p+tlen; let tick=0; let running=0; const evs=[];
    let tempoEvents=[];
    while(p<end){
      const dt = rdVLQ(); tick += dt;
      let st = u8[p++];
      if(st<0x80){ p--; st = running; } else { running = st; }
      if(st===0xFF){
        const type=u8[p++]; const len=rdVLQ(); const data=u8.slice(p,p+len); p+=len;
        if(type===0x51 && len===3){ const usPerQ = (data[0]<<16)|(data[1]<<8)|data[2]; tempoEvents.push({tick, usPerQ}); }
      }else if(st===0xF0 || st===0xF7){
        const len=rdVLQ(); p+=len;
      }else{
        const hi=st&0xF0, ch=st&0x0F;
        function d(){ return u8[p++]; }
        if(hi===0xC0 || hi===0xD0){ d(); }
        else{
          const d1=d(), d2=d();
          if(hi===0x90){ const note=d1, vel=d2; evs.push({type:(vel>0)?'on':'off', tick, ch, note, vel}); }
          else if(hi===0x80){ evs.push({type:'off', tick, ch, note:d1, vel:d2}); }
        }
      }
    }
    tracks.push({events:evs, tempos:tempoEvents});
  }

  let tempos = tracks.flatMap(tr=>tr.tempos);
  tempos.sort((a,b)=>a.tick-b.tick);
  if(!tempos.length || tempos[0].tick!==0) tempos.unshift({tick:0, usPerQ:500000});

  const segments = [];
  let lastTick=0, curUsPerQ=tempos[0].usPerQ, accSec=0;
  segments.push({tick:0, usPerQ:curUsPerQ, timeSec:0});
  for(let i=1;i<tempos.length;i++){
    const T = tempos[i].tick;
    accSec += ((T-lastTick) * curUsPerQ) / 1e6 / ppq;
    segments.push({tick:T, usPerQ:tempos[i].usPerQ, timeSec:accSec});
    lastTick = T; curUsPerQ = tempos[i].usPerQ;
  }
  function ticksToSec(t){
    let lo=0, hi=segments.length-1, idx=0;
    while(lo<=hi){ const mid=(lo+hi)>>1; if(segments[mid].tick<=t){ idx=mid; lo=mid+1; } else hi=mid-1; }
    const s=segments[idx];
    return s.timeSec + ((t - s.tick) * s.usPerQ) / 1e6 / ppq;
  }

  const all = tracks.flatMap(tr=>tr.events);
  all.sort((a,b)=> (a.tick-b.tick) || (a.type==='off'?1:-1));
  const onStack = Array.from({length:16}, ()=>Array(128).fill(null));
  const notes = [];
  let lastTickAll = 0;
  for(const e of all){
    lastTickAll = Math.max(lastTickAll, e.tick);
    if(e.type==='on'){
      onStack[e.ch][e.note] = onStack[e.ch][e.note] || [];
      onStack[e.ch][e.note].push({tick:e.tick, vel:e.vel});
    }else if(e.type==='off'){
      const st = onStack[e.ch][e.note];
      if(st && st.length){
        const on = st.shift();
        notes.push({note:e.note, chan:e.ch, vel:Math.max(1,on.vel), startTick:on.tick, endTick:e.tick});
      }
    }
  }
  for(let ch=0; ch<16; ch++){
    for(let n=0;n<128;n++){
      const st = onStack[ch][n];
      if(st && st.length){
        for(const on of st){
          notes.push({note:n, chan:ch, vel:Math.max(1,on.vel), startTick:on.tick, endTick:lastTickAll});
        }
      }
    }
  }
  for(const n of notes){ n.startSec = ticksToSec(n.startTick); n.endSec = ticksToSec(n.endTick); }
  const lengthSec = notes.reduce((m,n)=>Math.max(m, n.endSec), 0);

  const onsets = new Map();
  for(const n of notes){ const arr = onsets.get(n.startTick) || []; arr.push({note:n.note, vel:n.vel}); onsets.set(n.startTick, arr); }
  const onsetTicks = Array.from(onsets.keys()).sort((a,b)=>a-b);

  return { ppq, tracks, tempos, segments, ticksToSec, notes, lengthSec, onsets, onsetTicks };
  }

  function applyTransposeToMIDI(data, shift){
    if(!data) return null;
    const clampNote = (n)=>{
      const v = n + shift;
      return (v < 0 || v > 127) ? null : v;
    };
    const notes = [];
    for(const n of data.notes || []){
      const nn = clampNote(n.note);
      if(nn==null) continue;
      notes.push({...n, note: nn});
    }
    const onsets = new Map();
    if(data.onsets){
      data.onsets.forEach((arr, tk)=>{
        const mapped = arr.map(o=>({note: clampNote(o.note), vel: o.vel})).filter(o=>o.note!=null);
        if(mapped.length) onsets.set(tk, mapped);
      });
    }
    const onsetTicks = Array.from(onsets.keys()).sort((a,b)=>a-b);
    return {...data, notes, onsets, onsetTicks, transpose: shift};
  }

  function rebuildMidiView({preservePlayback = false} = {}){
    if(!midiDataRaw) return;
    const resume = preservePlayback && player;
    const resumeCtx = resume ? player.ctx : null;
    const resumeRunning = resume ? player.running : false;
    const resumePos = resume ? player.currentPosition() : 0;
    if(player){
      player.stop();
      player = null;
    }
    midiData = applyTransposeToMIDI(midiDataRaw, midiTranspose);
    trainer = new Trainer(midiData);
    updateTrainerUI();
    updateSeekUI(resumePos, midiData.lengthSec);
    const ctx = resumeCtx || ensureCtx();
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
    player.setPosition(resumePos);
    if(resumeRunning) player.play();
  }

  /* ===== Player ===== */
  class Player{
  constructor(ctx, notes){
    this.ctx=ctx; this.notes=notes;
    this.events = [];
    for(const n of notes){
      this.events.push({time:n.startSec, type:'on', note:n.note, vel:n.vel/127});
      this.events.push({time:n.endSec,   type:'off', note:n.note});
    }
    this.events.sort((a,b)=>a.time-b.time);
    this.nextIdx = 0;
    this.posSec = 0;
    this.t0Ctx = 0;
    this.timer = null;
    this.lookahead = 0.1; // s
    this.running = false;
    this.timeouts = new Set();
    this.onProgressCb = null;
  }
  onProgress(cb){ this.onProgressCb = cb; }
  emitProgress(){ if(this.onProgressCb) this.onProgressCb(this.currentPosition(), this.totalLength()); }
  clearTimers(){
    if(this.timer) clearTimeout(this.timer);
    this.timer = null;
    for(const to of this.timeouts) clearTimeout(to);
    this.timeouts.clear();
  }
  clearPlayingState(){
    this.clearTimers();
    fileNotes.clear();
    if(synth) synth.allNotesOff();
  }
  activateHeldNotes(posSec){
    if(!this.notes || !this.notes.length) return;
    const when = this.ctx.currentTime + 0.001;
    if(!synth) synth=new PolySynth(this.ctx);
    applySeekMuteState();
    for(const n of this.notes){
      if(n.startSec < posSec && n.endSec > posSec){
        const vel = n.vel/127;
        synth.noteOn(n.note, vel, when);
        fileNotes.set(n.note, vel);
      }
    }
  }
  currentPosition(){
    const now = this.running ? (this.ctx.currentTime - this.t0Ctx) : this.posSec;
    return Math.max(0, Math.min(now, this.totalLength()));
  }
  retargetIndex(){
    const pos = this.currentPosition();
    let idx = this.events.findIndex(ev => ev.time >= pos);
    this.nextIdx = idx < 0 ? this.events.length : idx;
  }
  scheduleUntil(tCut){
    const ctx=this.ctx;
    if(!synth) synth=new PolySynth(ctx);
    applySeekMuteState();
    while(this.nextIdx < this.events.length && this.events[this.nextIdx].time <= tCut){
      const ev = this.events[this.nextIdx++];
      const whenAbs = this.t0Ctx + ev.time;
      if(ev.type==='on'){
        synth.noteOn(ev.note, ev.vel||0.8, whenAbs);
        const delay = Math.max(0, (whenAbs - ctx.currentTime))*1000;
        const to = setTimeout(()=>{ fileNotes.set(ev.note, ev.vel||0.8); }, delay);
        this.timeouts.add(to);
      }else{
        synth.noteOff(ev.note, whenAbs);
        const delay = Math.max(0, (whenAbs - ctx.currentTime))*1000;
        const to = setTimeout(()=>{ fileNotes.delete(ev.note); }, delay+5);
        this.timeouts.add(to);
      }
    }
  }
  tick = ()=>{
    if(!this.running) return;
    const now = this.ctx.currentTime - this.t0Ctx;
    this.scheduleUntil(now + this.lookahead);
    this.emitProgress();
    if(now >= this.totalLength()){ this.stop(); return; }
    this.timer = setTimeout(this.tick, 20);
  }
  totalLength(){ return this.events.length? this.events[this.events.length-1].time : 0; }
  play(){
    if(this.running) return;
    this.t0Ctx = this.ctx.currentTime - this.posSec;
    this.running = true;
    this.emitProgress();
    this.activateHeldNotes(this.posSec);
    this.scheduleUntil(this.posSec + this.lookahead);
    this.tick();
  }
  pause(){
    if(!this.running) return;
    this.posSec = this.ctx.currentTime - this.t0Ctx;
    this.retargetIndex();
    this.running = false;
    this.clearTimers();
    this.clearPlayingState();
    this.emitProgress();
  }
  stop(){
    this.running = false; this.posSec = 0; this.nextIdx = 0;
    this.clearPlayingState();
    this.emitProgress();
  }
  setPosition(sec){
    const total = this.totalLength();
    const clamped = Math.max(0, Math.min(Number.isFinite(sec) ? sec : 0, total));
    this.posSec = clamped;
    this.retargetIndex();
    this.clearPlayingState();
    if(this.running){
      this.t0Ctx = this.ctx.currentTime - this.posSec;
      this.activateHeldNotes(this.posSec);
      this.scheduleUntil(this.posSec + this.lookahead);
      this.tick();
    }
    this.emitProgress();
  }
}
/* ===== Trainer（離鍵必須のエッジ検出） ===== */
class Trainer{
  constructor(midi){
    this.midi = midi;
    this.steps = midi.onsetTicks.map(tk => ({tick:tk, notes: midi.onsets.get(tk).map(o=>o.note)}));
    this.idx = 0;
    this.active = false;
    this.gateReady = true; // 成立の立ち上がりのみ許可するゲート
  }

  currentNotes(){ return (this.steps[this.idx]?.notes || []).slice().sort((a,b)=>a-b); }

  satisfied(live){
    const t = this.currentNotes();
    if(!t.length) return true;
    for(const n of t){ if(!live.has(n)) return false; }
    return true;
  }

  armAccordingToState(live){
    this.gateReady = !this.satisfied(live); // 既に成立していたら離鍵を要求
  }

  start(live = liveNotes){
    this.idx = 0;
    this.active = true;
    this.armAccordingToState(live);
  }

  next(live = liveNotes){
    if(!this.active) return;
    this.idx++;
    if(this.idx >= this.steps.length){ this.finish(); return; }
    this.armAccordingToState(live);
  }

  prev(live = liveNotes){
    if(!this.active) return;
    this.idx = Math.max(0, this.idx-1);
    this.armAccordingToState(live);
  }

  finish(){ this.active = false; }

  considerAdvance(live = liveNotes){
    if(!this.active) return;
    const ok = this.satisfied(live);
    if(!this.gateReady){
      if(!ok) this.gateReady = true; // 一度“不成立”になったら武装
      return;
    }
    if(ok){
      this.gateReady = false;        // 次は必ず離鍵
      this.next(live);
    }
  }
}
  /* ===== UI actions ===== */
  btnPlay.onclick = ()=>{
  if(!midiData){ fileInfo.textContent='file: –'; return; }
  const ctx = ensureCtx();
  try{ if(ctx.state==='suspended') ctx.resume(); }catch{}
  if(!player){
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
  }
  // 再生完了後は先頭から再生成、途中停止ならその位置から再開
  if(player.posSec >= player.totalLength()){
    player.stop();
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
  }
  player.play();
};
btnPause.onclick = ()=>{ if(player) player.pause(); };
btnStop.onclick = ()=>{ if(player) player.stop(); };
const beginSeekInteraction = ()=>{
  seekWasRunning = !!(player && player.running);
  if(player) player.pause();
  if(!seekMuting){ seekMuting = true; applySeekMuteState(); }
};
const endSeekInteraction = ()=>{
  if(seekMuting){ seekMuting = false; applySeekMuteState(); }
  if(seekWasRunning && player){ player.play(); }
  seekWasRunning = false;
};
seekSlider.addEventListener('pointerdown', beginSeekInteraction);
seekSlider.addEventListener('pointerup', endSeekInteraction);
seekSlider.addEventListener('pointercancel', endSeekInteraction);
addEventListener('pointerup', endSeekInteraction);
addEventListener('pointercancel', endSeekInteraction);
seekSlider.addEventListener('input', ()=>{
  if(!midiData) return;
  if(!player){
    const ctx = ensureCtx();
    player = new Player(ctx, midiData.notes);
    player.onProgress(updateSeekUI);
  }
  const raw = parseFloat(seekSlider.value);
  const frac = Math.max(0, Math.min(1, Number.isNaN(raw) ? 0 : raw / 1000));
  const target = frac * player.totalLength();
  if(Number.isFinite(target)) player.setPosition(target);
});

btnStartTrain.onclick = ()=>{
  if(!midiData){ fileInfo.textContent='file: –'; return; }
  if(player) player.stop();
  trainer = new Trainer(midiData);
  trainer.start(liveNotes);   // 開始時点の押下状態でゲート初期化
  updateTrainerUI();
};
btnPrev.onclick = ()=>{ if(trainer && trainer.active){ trainer.prev(liveNotes); updateTrainerUI(); } };
btnNext.onclick = ()=>{ if(trainer && trainer.active){ trainer.next(liveNotes); updateTrainerUI(); } };

function updateTrainerUI(){
  if(trainer && trainer.active){
    const tn = trainer.currentNotes();
    trainerStat.textContent = `step: ${trainer.idx+1}/${trainer.steps.length}  notes: [${tn.join(', ')}]`;
  }else if(trainer && !trainer.active){
    trainerStat.textContent = `step: done (${trainer?.steps?.length||0})`;
  }else{
    trainerStat.textContent = 'step: –';
  }
}

/* ===== Keyboard shortcuts ===== */
addEventListener('keydown', e=>{
  if(fileOp.value==='train' && trainer && trainer.active){
    if(e.key==='ArrowLeft'){ trainer.prev(liveNotes); updateTrainerUI(); }
    else if(e.key==='ArrowRight'){ trainer.next(liveNotes); updateTrainerUI(); }
  }
});
</script>
